<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Morphia</title>
    <link>/morphia/1.0/</link>
    <description>Recent content on Morphia</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 18 Mar 2015 16:56:14 +0000</lastBuildDate>
    <atom:link href="/morphia/1.0/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Issues &amp; Help</title>
      <link>/morphia/1.0/issues-help/</link>
      <pubDate>Wed, 18 Mar 2015 16:56:14 +0000</pubDate>
      
      <guid>/morphia/1.0/issues-help/</guid>
      <description>

&lt;h1 id=&#34;issues-help&#34;&gt;Issues &amp;amp; Help&lt;/h1&gt;

&lt;p&gt;We are lucky to have a vibrant MongoDB Java community with lots of varying
experience of using Morphia.  We often find the quickest way to get support for
general questions is through the &lt;a href=&#34;https://groups.google.com/forum/#!forum/morphia&#34;&gt;Morphia google group&lt;/a&gt;,
&lt;a href=&#34;http://groups.google.com/group/mongodb-user&#34;&gt;mongodb-user google group&lt;/a&gt;,
or through &lt;a href=&#34;https://stackoverflow.com/questions/tagged/morphia&#34;&gt;stackoverflow&lt;/a&gt;.  Please also
refer to our own &lt;a href=&#34;http://www.mongodb.org/about/support&#34;&gt;support channels&lt;/a&gt; documentation.  If you have a question or think you&amp;rsquo;ve
encountered a bug, the mailing list is the place to start.&lt;/p&gt;

&lt;h2 id=&#34;bugs-feature-requests&#34;&gt;Bugs / Feature Requests&lt;/h2&gt;

&lt;p&gt;If you think you’ve found a bug or want to see a new feature in the Morphia, please open an issue on
 &lt;a href=&#34;https://github.com/mongodb/morphia/issues&#34;&gt;github&lt;/a&gt;. Please provide as much information as possible (including version numbers) about the
 issue type and how to reproduce it.&lt;/p&gt;

&lt;p&gt;If you’ve identified a security vulnerability in a driver or any other
MongoDB project, please report it according to the &lt;a href=&#34;http://docs.mongodb.org/manual/tutorial/create-a-vulnerability-report&#34;&gt;instructions here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;pull-requests&#34;&gt;Pull Requests&lt;/h2&gt;

&lt;p&gt;We are happy to accept contributions to help improve Morphia.  We will guide user contributions to ensure they meet the standards of the
codebase. Please ensure that any pull requests include documentation, tests and also pass a the gradle checks.&lt;/p&gt;

&lt;p&gt;To get started check out the source and work on a branch:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone https://github.com/mongodb/morphia.git
$ cd morphia
$ git checkout -b myNewFeature
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, ensure that the code passes gradle checks.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./gradlew check
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Getting Started</title>
      <link>/morphia/1.0/getting-started/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/morphia/1.0/getting-started/</guid>
      <description>

&lt;h2 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h2&gt;

&lt;p&gt;To help you get started quickly with Morphia follow:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/morphia/1.0/morphia/1.0/getting-started/installation-guide/&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/morphia/1.0/morphia/1.0/getting-started/quick-tour/&#34;&gt;Quick Tour&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Annotations</title>
      <link>/morphia/1.0/guides/annotations/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/morphia/1.0/guides/annotations/</guid>
      <description>

&lt;h1 id=&#34;annotations&#34;&gt;Annotations&lt;/h1&gt;

&lt;p&gt;Below is a list of all the annotations and a brief descriptions of how to use them.&lt;/p&gt;

&lt;h2 id=&#34;entity&#34;&gt;Entity&lt;/h2&gt;

&lt;p&gt;Marks entities to be stored directly in a collection. This annotations is optional in most cases (though this is likely to change in
future versions). There is no harm in including it to be more verbose, and make clear the intention for the class.  The definition of
this annotation looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface Entity {
  String value() default Mapper.IGNORED_FIELDNAME;
  CappedAt cap() default @CappedAt(0);
  boolean noClassnameStored() default false;
  boolean queryNonPrimary() default false;
  String concern() default &amp;quot;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;value()&lt;/td&gt;
&lt;td&gt;Defines the collection to use.  Defaults to using the classname&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cap()&lt;/td&gt;
&lt;td&gt;Marks this collection as capped and sets the size to use.  See the &lt;a href=&#34;#capped&#34;&gt;&lt;code&gt;@Capped&lt;/code&gt;&lt;/a&gt; below&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;noClassnameStored()&lt;/td&gt;
&lt;td&gt;Tells Morphia to not store the classname in the document.  The default is to store the classname.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;queryNonPrimary()&lt;/td&gt;
&lt;td&gt;Indicates that queries against this collection can use secondaries.  The default is primary only reads.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;concern()&lt;/td&gt;
&lt;td&gt;The WriteConcern to use when writing to this collection.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;indexes&#34;&gt;Indexes&lt;/h2&gt;

&lt;p&gt;In addition to being able to declare an index on a single field you can also declare the indexes at the class level. This allows you to
 create more than just a single field index; it allows you to create compound indexes with multiple fields.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface Indexes {
    Index[] value();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;index&#34;&gt;Index&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface Index {
    String value() default &amp;quot;&amp;quot;;
    String name() default &amp;quot;&amp;quot;;
    boolean unique() default false;
    boolean dropDups() default false;
    boolean background() default false;
    boolean sparse() default false;
    boolean disableValidation() default false;
    int expireAfterSeconds() default -1;

    Field[] fields() default {};
    IndexOptions options() default @IndexOptions();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two pieces to this annotation that are mutually exclusive.  The first group of parameters are considered legacy.  They are safe
 to use since but are unlikely to survive past the 1.x series.  These options and more have been conglomerated in the &lt;code&gt;@Field&lt;/code&gt; annotation.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;value()&lt;/td&gt;
&lt;td&gt;List of fields (prepended with &amp;ldquo;-&amp;rdquo; for desc; defaults to asc).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;name()&lt;/td&gt;
&lt;td&gt;The name of the index&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;unique()&lt;/td&gt;
&lt;td&gt;Requires values in the index to be unique&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dropDups()&lt;/td&gt;
&lt;td&gt;Drop any duplicate values during the creation of a unique index.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;background()&lt;/td&gt;
&lt;td&gt;Create this index in the background.  There are some &lt;a href=&#34;http://docs.mongodb.org/manual/tutorial/build-indexes-in-the-background/#considerations&#34;&gt;considerations&lt;/a&gt; to keep in mind.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;sparse()&lt;/td&gt;
&lt;td&gt;Create a &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-sparse/&#34;&gt;sparse&lt;/a&gt; index&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;disableValidation()&lt;/td&gt;
&lt;td&gt;By default, Morphia will validate field names being index.  This disables those checks.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;expireAfterSeconds()&lt;/td&gt;
&lt;td&gt;Creates a &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-ttl/&#34;&gt;TTL Index&lt;/a&gt; on a date field.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;fields()&lt;/td&gt;
&lt;td&gt;This is the new way to define which fields to index. &lt;a href=&#34;#Field&#34;&gt;Details&lt;/a&gt; can be found below.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;options()&lt;/td&gt;
&lt;td&gt;This is the new way to define index options. &lt;a href=&#34;#IndexOptions&#34;&gt;Details&lt;/a&gt; can be found below.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;field&#34;&gt;Field&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; public @interface Field {
     String value();
     IndexType type() default IndexType.ASC;
     int weight() default -1;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;value()&lt;/td&gt;
&lt;td&gt;The field to include in the index&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;type()&lt;/td&gt;
&lt;td&gt;The type of index to create.  This includes the following values:   &lt;code&gt;ASC&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt;, &lt;code&gt;GEO2D&lt;/code&gt;, &lt;code&gt;GEO2DSPHERE&lt;/code&gt;, &lt;code&gt;TEXT&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;weight()&lt;/td&gt;
&lt;td&gt;When defining a text index, this is the weight to apply&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;indexoptions&#34;&gt;IndexOptions&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface IndexOptions {
    String name() default &amp;quot;&amp;quot;;
    boolean unique() default false;
    boolean dropDups() default false;
    boolean background() default false;
    boolean sparse() default false;
    boolean disableValidation() default false;
    int expireAfterSeconds() default -1;
    String language() default &amp;quot;&amp;quot;;
    String languageOverride() default &amp;quot;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;name()&lt;/td&gt;
&lt;td&gt;The name of the index&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;unique()&lt;/td&gt;
&lt;td&gt;Requires values in the index to be unique&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dropDups()&lt;/td&gt;
&lt;td&gt;Drop any duplicate values during the creation of a unique index.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;background()&lt;/td&gt;
&lt;td&gt;Create this index in the background.  There are some &lt;a href=&#34;http://docs.mongodb.org/manual/tutorial/build-indexes-in-the-background/#considerations&#34;&gt;considerations&lt;/a&gt; to keep in mind.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;sparse()&lt;/td&gt;
&lt;td&gt;Create a &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-sparse/&#34;&gt;sparse&lt;/a&gt; index&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;expireAfterSeconds()&lt;/td&gt;
&lt;td&gt;Creates a &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-ttl/&#34;&gt;TTL Index&lt;/a&gt; on a date field.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;disableValidation()&lt;/td&gt;
&lt;td&gt;By default, Morphia will validate field names being index.  This disables those checks.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;language()&lt;/td&gt;
&lt;td&gt;Default language for the index.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;languageOverride()&lt;/td&gt;
&lt;td&gt;The field in the document to use to override the default language.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;indexed&#34;&gt;Indexed&lt;/h4&gt;

&lt;p&gt;Applied to a Java field, marks the field to be indexed by mongodb.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface Indexed {
    IndexDirection value() default IndexDirection.ASC;
    String name() default &amp;quot;&amp;quot;;
    boolean unique() default false;
    boolean dropDups() default false;
    boolean background() default false;
    boolean sparse() default false;
    int expireAfterSeconds() default -1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;value()&lt;/td&gt;
&lt;td&gt;The sort direction for the index&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;name()&lt;/td&gt;
&lt;td&gt;The name of the index&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;unique()&lt;/td&gt;
&lt;td&gt;Requires values in the index to be unique&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dropDups()&lt;/td&gt;
&lt;td&gt;Drop any duplicate values during the creation of a unique index.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;background()&lt;/td&gt;
&lt;td&gt;Create this index in the background.  There are some &lt;a href=&#34;http://docs.mongodb.org/manual/tutorial/build-indexes-in-the-background/#considerations&#34;&gt;considerations&lt;/a&gt; to keep in mind.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;sparse()&lt;/td&gt;
&lt;td&gt;Create a &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-sparse/&#34;&gt;sparse&lt;/a&gt; index&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;expireAfterSeconds()&lt;/td&gt;
&lt;td&gt;Creates a &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-ttl/&#34;&gt;TTL Index&lt;/a&gt; on a date field.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;id&#34;&gt;Id&lt;/h2&gt;

&lt;p&gt;Marks a field in an &lt;code&gt;@Entity&lt;/code&gt; to be the &amp;ldquo;_id&amp;rdquo; field in mongodb.&lt;/p&gt;

&lt;h2 id=&#34;property&#34;&gt;Property&lt;/h2&gt;

&lt;p&gt;An optional annotation instructing Morphia to persist field in to the document given to mongodb.  By default, the field name is used as
the property name.  This can be overridden by passing a String with the new name to the annotation.&lt;/p&gt;

&lt;h2 id=&#34;transient&#34;&gt;Transient&lt;/h2&gt;

&lt;p&gt;Instructs Morphia to ignore this field when converting an entity to a document.  The java keyword &lt;code&gt;transient&lt;/code&gt; can also be used instead.&lt;/p&gt;

&lt;h2 id=&#34;serialized&#34;&gt;Serialized&lt;/h2&gt;

&lt;p&gt;Instructs Morphia to serialize this field.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface Serialized {
  String value() default Mapper.IGNORED_FIELDNAME;
  boolean disableCompression() default false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;value()&lt;/td&gt;
&lt;td&gt;the field name to use in the document&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;disableCompression()&lt;/td&gt;
&lt;td&gt;By default, Morphia compresses the &lt;code&gt;byte[]&lt;/code&gt; after serialization.  Setting this to true disables the compression.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;notsaved&#34;&gt;NotSaved&lt;/h2&gt;

&lt;p&gt;Instructs Morphia to ignore this field when saving but will still be loaded.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Good for data migration.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;alsoload&#34;&gt;AlsoLoad&lt;/h2&gt;

&lt;p&gt;When a field gets remapped to a new name, you can either update the database and migrate all the fields at once or use this annotation
to tell Morphia what older names to try if the current one fails.  It is an error to have values under both the old and new key names
when loading a document.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Good for data migration.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface AlsoLoad {
  String[] value();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;value()&lt;/td&gt;
&lt;td&gt;The array of names to try when loading the field&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;version&#34;&gt;Version&lt;/h2&gt;

&lt;p&gt;Marks a field in an &lt;code&gt;@Entity&lt;/code&gt; to control optimistic locking for that entity. If the versions change while modifying an entity (including
deletes) a &lt;code&gt;ConcurrentModificationException&lt;/code&gt; will be thrown. This field will be automatically managed for you &amp;ndash; there is no need to set
 a value and you should not do so anyway.  If the another name beside the Java field name is desired, a name can be passed to this
 annotation to change the document&amp;rsquo;s field name.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Entity
class MyClass {
   ...
   @Version Long v;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;p&gt;Marks fields as stored in another collection and which are linked (by a &lt;code&gt;DBRef&lt;/code&gt; field). When the Entity is loaded, the referenced Entity
 can also be loaded.  Any document referenced via an &lt;code&gt;@Reference&lt;/code&gt; field must have already been saved in mongodb or have the Java object&amp;rsquo;s
  &lt;code&gt;@Id&lt;/code&gt; already assigned.  Otherwise, no key can be copied in to the &lt;code&gt;Key&lt;/code&gt; for storage in the database.  If you&amp;rsquo;re always saving the
  referenced entity in the mapped collection (&lt;code&gt;Datastore&lt;/code&gt; can be told to save in to a collection other than the mapped collection) a lot
  of space can be saved by using the &lt;code&gt;idOnly()&lt;/code&gt; parameter to just save the key value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface Reference {
  String value() default Mapper.IGNORED_FIELDNAME;
  Class&amp;lt;?&amp;gt; concreteClass() default Object.class;
  boolean ignoreMissing() default false;
  boolean lazy() default false;
  boolean idOnly() default false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;value()&lt;/td&gt;
&lt;td&gt;The field name to use in the document.  Defaults to the Java field name.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ignoreMissing()&lt;/td&gt;
&lt;td&gt;Ignore any missing documents&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;lazy()&lt;/td&gt;
&lt;td&gt;Instructs Morphia to defer loading of the referenced document.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;idOnly()&lt;/td&gt;
&lt;td&gt;Instructs Morphia to only store the key of the referenced document rather than a full &lt;code&gt;DBRef&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;embedded&#34;&gt;Embedded&lt;/h2&gt;

&lt;p&gt;In contrast to &lt;code&gt;@Reference&lt;/code&gt; where a nested Java reference ends up as a separate document in a collection, &lt;code&gt;@Embedded&lt;/code&gt; tells Morphia
to embed the document created from the Java object in the document of the parent object.  This annotation can be applied to the class of
the embedded type or on the field holding the embedded instance.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface Embedded {
  String value() default Mapper.IGNORED_FIELDNAME;
  Class&amp;lt;?&amp;gt; concreteClass() default Object.class;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;value()&lt;/td&gt;
&lt;td&gt;The field name to use in the document.  Defaults to the Java field name.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;concreteClass()&lt;/td&gt;
&lt;td&gt;The concrete class to use when instantiating the embedded entity&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;lifecycle-annotations&#34;&gt;Lifecycle Annotations&lt;/h2&gt;

&lt;p&gt;There are various annotations which can be used to register callbacks on certain lifecycle events. These include Pre/Post-Persist (Save), and Pre/Post-Load.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@PreLoad&lt;/code&gt; - Called before mapping the datastore object to the entity (POJO); the DBObject is passed as an argument (you can add/remove/change values)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PostLoad&lt;/code&gt; - Called after mapping to the entity&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PrePersist&lt;/code&gt; - Called before save, it can return a DBObject in place of an empty one.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PostPersist&lt;/code&gt; - Called after the save call to the datastore&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PostSave&lt;/code&gt; - Called before the save call to the datastore&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mongodb/morphia/blob/master/morphia/src/test/java/org/mongodb/morphia/TestQuery.java#L63&#34;&gt;Here&lt;/a&gt; is a one of the test classes.&lt;/p&gt;

&lt;p&gt;All parameters and return values are options in your implemented methods.&lt;/p&gt;

&lt;h4 id=&#34;prepersist&#34;&gt;&lt;code&gt;@PrePersist&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;Here is a simple example of an entity that always saves the Date it was last updated at.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class BankAccount {
  @Id String id;
  Date lastUpdated = new Date();

  @PrePersist void prePersist() {lastUpdated = new Date();}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;entitylisteners&#34;&gt;&lt;code&gt;@EntityListeners&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;In addition, you can separate the lifecycle event implementation in an external class, or many.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@EntityListeners(BackAccountWatcher.class)
public class BankAccount {
  @Id String id;
  Date lastUpdated = new Date();
}

class BankAccountWatcher{

  @PrePersist void prePersist(BankAccount act) {act.lastUpdated = new Date();}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;no-delete-support&#34;&gt;No Delete Support&lt;/h3&gt;

&lt;p&gt;Because deletes are usually done with queries there is no way to support a Delete lifecycle event. If, or when, server-side triggers are
  enabled there may be some support for this, but even then it will be hard to imagine how this would logically fit.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Installation Guide</title>
      <link>/morphia/1.0/getting-started/installation-guide/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/morphia/1.0/getting-started/installation-guide/</guid>
      <description>

&lt;h1 id=&#34;installation&#34;&gt;Installation&lt;/h1&gt;

&lt;p&gt;The recommended way to get started using Morphia in your project is with a dependency management system.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;pull-right&#34;&gt;
  &lt;input type=&#34;checkbox&#34; checked=&#34;&#34; class=&#34;distroPicker&#34; data-toggle=&#34;toggle&#34; data-on=&#34;Maven&#34; data-off=&#34;Gradle&#34; data-offstyle=&#34;success&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;section class=&#34;maven&#34;&gt;
&lt;pre&gt;&lt;code class=&#34;ini&#34;&gt;
&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.mongodb.morphia&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;morphia&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0.0-rc0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section class=&#34;gradle hidden&#34;&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
      compile &#39;org.mongodb.morphia:morphia:1.0.0-rc0&#39;
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section class=&#34;downloadInfo&#34;&gt;
&lt;p class=&#34;small&#34;&gt;You can also download the jars
  &lt;a href=&#34;https://oss.sonatype.org/content/repositories/releases/org/mongodb/morphia/morphia/1.0.0-rc0&#34; target=&#34;_blank&#34;&gt;directly&lt;/a&gt;
  from sonatype.&lt;/a&gt;
&lt;/p&gt;

&lt;/section&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reference Guides</title>
      <link>/morphia/1.0/guides/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/morphia/1.0/guides/</guid>
      <description>

&lt;h2 id=&#34;reference-guides&#34;&gt;Reference Guides&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/morphia/1.0/morphia/1.0/guides/annotations/&#34;&gt;Annotations&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Morphia</title>
      <link>/morphia/1.0/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/morphia/1.0/</guid>
      <description>

&lt;h2 id=&#34;morphia-documentation&#34;&gt;Morphia Documentation&lt;/h2&gt;

&lt;p&gt;Welcome to the Morphia documentation hub.&lt;/p&gt;

&lt;p&gt;Morphia is built upon the
&lt;a href=&#34;https://github.com/mongodb/mongo-java-driver/&#34;&gt;&lt;code&gt;MongoDB Java Driver&lt;/code&gt;&lt;/a&gt;.
For reference documentation please see the driver documentation.&lt;/p&gt;

&lt;h3 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;/morphia/1.0/morphia/1.0/getting-started/&#34;&gt;Getting Started&lt;/a&gt; guide contains installation instructions
and a simple tutorial to get up and running quickly.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quick Tour</title>
      <link>/morphia/1.0/getting-started/quick-tour/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/morphia/1.0/getting-started/quick-tour/</guid>
      <description>

&lt;h1 id=&#34;quick-tour&#34;&gt;Quick Tour&lt;/h1&gt;

&lt;p&gt;Morphia wraps the mongodb Java driver so some level of familiarity with using the driver can be helpful.  Morphia does its best to
abstract much of that away but if something is confusing it wouldn&amp;rsquo;t hurt to consult the Java driver &lt;a href=&#34;http://mongodb.github
.io/mongo-java-driver/&#34;&gt;documentation&lt;/a&gt; as well.&lt;/p&gt;

&lt;p&gt;The following code snippets come from the &lt;code&gt;QuickTour.java&lt;/code&gt; example code
that can be found with the &lt;a href=&#34;https://github.com/mongodb/morphia/blob/1.0.x/morphia/src/test/examples/java/org/mongodb/morphia/examples/QuickTour.java
&#34;&gt;Morphia source&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;setting-up-morphia&#34;&gt;Setting up Morphia&lt;/h2&gt;

&lt;p&gt;The following example shows how to create the initial Morphia instance.  Using this instance, you can configure various aspects of how
Morphia maps your entities and validates your queries.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Morphia morphia = new Morphia();

// tell Morphia where to find your classes
// can be called multiple times with different packages or classes
morphia.mapPackage(&amp;quot;org.mongodb.morphia.example&amp;quot;);

// create the Datastore connecting to the database running on the default port on the local host
final Datastore datastore = morphia.createDatastore(new MongoClient(), &amp;quot;morphia_example&amp;quot;);
datastore.ensureIndexes();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This snippet creates the Morphia instance we&amp;rsquo;ll be using in our simple application.  The &lt;code&gt;Morphia&lt;/code&gt; class exists to configure the &lt;code&gt;Mapper&lt;/code&gt;
 to be used and to define various system-wide defaults.  It is also what is used to create the &lt;code&gt;Datastore&lt;/code&gt; we&amp;rsquo;ll be using.  With this
 approach we could conceivable configure Morphia once and then connect to multiple databases by creating different &lt;code&gt;Datastore&lt;/code&gt; instances.
   In practice, this is likely pretty rare but it is possible.  The &lt;code&gt;Datastore&lt;/code&gt; takes two parameters:  the &lt;code&gt;MongoClient&lt;/code&gt; used to connect
   to mongodb and the name of the database to use.&lt;/p&gt;

&lt;p&gt;The second line, which we skipped over, deserves a bit of consideration.  In this case, we&amp;rsquo;re telling Morphia to look at every class in the
package we&amp;rsquo;ve given and find every class annotated with &lt;code&gt;@Entity&lt;/code&gt; (which we&amp;rsquo;ll cover shortly) and discover the mapping metadata we&amp;rsquo;ve
put on our classes.  There are several variations of mapping that can be done and they can be called multiple times with different values
 to properly cover all your entities wherever they might live in your application.&lt;/p&gt;

&lt;h2 id=&#34;mapping-classes&#34;&gt;Mapping Classes&lt;/h2&gt;

&lt;p&gt;There are two ways that Morphia can handle your classes:  as top level entities or embedded in others.  Any class annotated with &lt;code&gt;@Entity&lt;/code&gt;
 is treated as a top level document stored directly in a collection.  Any class with &lt;code&gt;@Entity&lt;/code&gt; must have a field annotated with &lt;code&gt;@Id&lt;/code&gt; to
define which field to use as the &lt;code&gt;_id&lt;/code&gt; value in the document written to mongodb.  &lt;code&gt;@Embedded&lt;/code&gt; indicates that the class will result in a
subdocument inside another document.  &lt;code&gt;@Embedded&lt;/code&gt; classes do not require the presence of an &lt;code&gt;@Id&lt;/code&gt; field.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Entity(&amp;quot;employees&amp;quot;)
@Indexes(
    @Index(value = &amp;quot;salary&amp;quot;, fields = @Field(&amp;quot;salary&amp;quot;))
)
class Employee {
    @Id
    private ObjectId id;
    private String name;
    @Reference
    private Employee manager;
    @Reference
    private List&amp;lt;Employee&amp;gt; directReports;
    @Property(&amp;quot;wage&amp;quot;)
    private Double salary;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a few things here to discuss and others we&amp;rsquo;ll defer to later sections.  This class is annotated using the &lt;code&gt;@Entity&lt;/code&gt; annotation
so we know that it will be a top level document.  In the annotation, you&amp;rsquo;ll see &lt;code&gt;&amp;quot;employees&amp;quot;&lt;/code&gt;.  By default, Morphia will use the class
name as the collection name.  If you pass a String instead, it will use that value for the collection name.  In this case, all
&lt;code&gt;Employee&lt;/code&gt; instances will be saved in to the &lt;code&gt;employees&lt;/code&gt; collection instead.  There is a little more to this annotation but the
&lt;a href=&#34;/morphia/1.0/morphia/1.0/guides/annotations/#entity&#34;&gt;annotations guide&lt;/a&gt; covers those details.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;@Indexes&lt;/code&gt; annotation lists which annotations Morphia should create.  In this instance, we&amp;rsquo;re defining an index named &lt;code&gt;salary&lt;/code&gt; on the
 field salary with the default ordering of ascending.  More information on indexing can found
  &lt;a href=&#34;/morphia/1.0/morphia/1.0/guides/annotations/#indexes&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve marked the &lt;code&gt;id&lt;/code&gt; field to be used as our primary key (the &lt;code&gt;_id&lt;/code&gt; field in the document).  In this instance we&amp;rsquo;re using the Java driver
type of &lt;code&gt;ObjectId&lt;/code&gt; as the ID type.  The ID can be any type you&amp;rsquo;d like but is generally something like &lt;code&gt;ObjectId&lt;/code&gt; or &lt;code&gt;Long&lt;/code&gt;.  There are
two other annotations to cover but it should be pointed out now that other than transient and static fields, Morphia will attempt copy
every field&amp;rsquo;s value in to a document bound for the database.&lt;/p&gt;

&lt;p&gt;The simplest of the two remaining annotations is &lt;code&gt;@Property&lt;/code&gt;.  This annotation is entirely optional.  If you leave this annotation off,
Morphia will use the Java field name as the document field name.  Often times this is fine.  However, some times you&amp;rsquo;ll want to change
the document field name for any number of reasons.  In those cases, you can use &lt;code&gt;@Property&lt;/code&gt; and pass it the name to be used when this
class is serialized out to a document to be handed off to mongodb.&lt;/p&gt;

&lt;p&gt;This just leaves &lt;code&gt;@Reference&lt;/code&gt;.  This annotation is telling Morphia that this field refers to other Morphia mapped entities.  In this case
Morphia will store what mongodb calls a &lt;code&gt;DBRef&lt;/code&gt; which is just a collection name and key value.  These referenced entities must already be
 saved or at least have an ID assigned or Morphia will throw an exception.&lt;/p&gt;

&lt;h2 id=&#34;saving-data&#34;&gt;Saving Data&lt;/h2&gt;

&lt;p&gt;For the most part, you treat your Java objects just like you normally would.  When you&amp;rsquo;re ready to write an object to the database, it&amp;rsquo;s
as simple as this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Employee elmer = new Employee(&amp;quot;Elmer Fudd&amp;quot;, 50000.0);
datastore.save(elmer);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Taking it one step further, lets define some relationships and save those, too.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Employee daffy = new Employee(&amp;quot;Daffy Duck&amp;quot;, 40000.0);
datastore.save(daffy);

final Employee pepe = new Employee(&amp;quot;Pepé Lepew&amp;quot;, 25000.0);
datastore.save(pepe);

elmer.getDirectReports().add(daffy);
elmer.getDirectReports().add(pepe);

datastore.save(elmer);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, we just need to create and save the other Employees then we can add them to the direct reports list and
save.  Morphia takes care of saving the keys in Elmer&amp;rsquo;s document that refer to Daffy and Pepé.  Updating data in mongodb is as simple as
updating your Java objects and then calling &lt;code&gt;datastore.save()&lt;/code&gt; with them again.  For bulk updates (everyone gets a raise!) this is not
the most efficient way doing updates.  It is possible to update directly in the database without having to pull in every document,
convert to Java objects, update, convert back to a document, and write back to mongodb.  But in order to show you that piece, first we need
 to
see
how to query.&lt;/p&gt;

&lt;h2 id=&#34;querying&#34;&gt;Querying&lt;/h2&gt;

&lt;p&gt;Morphia attempts to make your queries as type safe as possible.  All of the details of converting your data are handled by Morphia
directly and only rarely do you need to take additional action.  As with everything else, &lt;code&gt;Datastore&lt;/code&gt; is where we start:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Query&amp;lt;Employee&amp;gt; query = datastore.createQuery(Employee.class);
final List&amp;lt;Employee&amp;gt; employees = query.asList();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a basic Morphia query.  Here, we&amp;rsquo;re telling the &lt;code&gt;Datastore&lt;/code&gt; to create a query that&amp;rsquo;s been typed to &lt;code&gt;Employee&lt;/code&gt;.  In this
case, we&amp;rsquo;re fetching every &lt;code&gt;Employee&lt;/code&gt; in to a &lt;code&gt;List&lt;/code&gt;.  Ignoring the obvious potential for memory errors, this is not usually that helpful
.  Most queries will, of course, want to filter the data in some way.  There are two ways of doing this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Employee&amp;gt; underpaid = datastore.createQuery(Employee.class)
                                    .filter(&amp;quot;salary &amp;lt;=&amp;quot;, 30000)
                                    .asList();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This approach uses the &lt;code&gt;filter()&lt;/code&gt; method which is a little more freeform than the alternative.  Here we can embed certain operators in
the query string.  While this is less verbose than the alternative, it does leave more things in the string to validate and potentially
get wrong.  If you prefer more compile-time validation, this approach creates the same query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;underpaid = datastore.createQuery(Employee.class)
                     .field(&amp;quot;salary&amp;quot;).lessThanOrEq(30000)
                     .asList();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Either query works.  It comes down to a question of preference in most cases.  In either approach, Morphia will validate that there is a
field called &lt;code&gt;salary&lt;/code&gt; on the &lt;code&gt;Employee&lt;/code&gt; class.  If you happen to have mapped that field such that the name in the database doesn&amp;rsquo;t match
the Java field, Morphia can use either form and will validate against either name.&lt;/p&gt;

&lt;h2 id=&#34;updates&#34;&gt;Updates&lt;/h2&gt;

&lt;p&gt;Now that we can query, however simply, we can turn to in-database updates.  These updates take two components: a query, and a set
of update operations.  In this example, we&amp;rsquo;ll find all the underpaid employees and give them raise of 10000.  The first step is to create
 the query to find all the underpaid employees.  This is one we&amp;rsquo;ve already seen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Query&amp;lt;Employee&amp;gt; underPaidQuery = datastore.createQuery(Employee.class)
                                             .filter(&amp;quot;salary &amp;lt;=&amp;quot;, 30000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To define how we want to update the documents matched by this query, we create an &lt;code&gt;UpdateOperations&lt;/code&gt; instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final UpdateOperations&amp;lt;Employee&amp;gt; updateOperations = datastore.createUpdateOperations(Employee.class)
                                                   .inc(&amp;quot;salary&amp;quot;, 10000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are many operations on this class but, in this case, we&amp;rsquo;re only updating the &lt;code&gt;salary&lt;/code&gt; field by 10000.  This corresponds to the
&lt;a href=&#34;http://docs.mongodb.org/manual/reference/operator/update/inc/&#34;&gt;&lt;code&gt;$inc&lt;/code&gt; operator&lt;/a&gt;.  There&amp;rsquo;s one last step involved here:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final UpdateResults results = datastore.update(underPaidQuery, updateOperations);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This line executes the update in the database without having to pull in however many documents are matched by the query.  The
&lt;code&gt;UpdateResults&lt;/code&gt; instance returned will contain various statistics about the update operation.&lt;/p&gt;

&lt;h2 id=&#34;removes&#34;&gt;Removes&lt;/h2&gt;

&lt;p&gt;After everything else, removes are really quite simple.  Removing just needs a query to find and delete the documents in question and
then tell the &lt;code&gt;Datastore&lt;/code&gt; to delete them:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Query&amp;lt;Employee&amp;gt; overPaidQuery = datastore.createQuery(Employee.class)
                                                .filter(&amp;quot;salary &amp;gt;&amp;quot;, 100000);
datastore.delete(overPaidQuery);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a couple of variations on &lt;code&gt;delete()&lt;/code&gt; but this is probably the most common usage.  If you already have an object in hand, there
is a &lt;code&gt;delete&lt;/code&gt; that can take that reference and delete it.  There is more information in the &lt;a href=&#34;/morphia/1.0/javadoc&#34;&gt;javadoc&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>