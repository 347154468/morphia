<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Guides on Morphia</title>
    <link>/morphia/1.4/guides/index.xml</link>
    <description>Recent content in Guides on Morphia</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 17 Mar 2015 15:36:56 +0000</lastBuildDate>
    <atom:link href="/morphia/1.4/guides/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Annotations</title>
      <link>/morphia/1.4/guides/annotations/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/morphia/1.4/guides/annotations/</guid>
      <description>

&lt;h1 id=&#34;annotations&#34;&gt;Annotations&lt;/h1&gt;

&lt;p&gt;Below is a list of all the annotations and a brief description of how to use them.&lt;/p&gt;

&lt;h2 id=&#34;indexes&#34;&gt;Indexes&lt;/h2&gt;

&lt;p&gt;Indexes can be defined on each field directly for single field indexing or at the class level for compund indexes.  To see the next few
annotations in context, please refer to &lt;a href=&#34;https://github.com/mongodb/morphia/blob/master/morphia/src/test/java/org/mongodb/morphia/TestIndexCollections.java
&#34;&gt;TestIndexCollections.java&lt;/a&gt; or &lt;a href=&#34;https://github.com/mongodb/morphia/blob/master/morphia/src/test/java/org/mongodb/morphia/indexes/TestIndexed.java
&#34;&gt;TestIndexed.java&lt;/a&gt; in the Morphia source.&lt;/p&gt;

&lt;h3 id=&#34;index&#34;&gt;Index&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;@Index&lt;/code&gt; documentation can be found &lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/annotations/Index.html
&#34;&gt;here&lt;/a&gt;.  There are two pieces to this
annotation that are mutually exclusive.  The first group of parameters are considered legacy.  They are safe to use but will be removed
in the 2.x series.  These options and more have been conglomerated in the
&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/annotations/IndexOptions.html
&#34;&gt;&lt;code&gt;@IndexOptions&lt;/code&gt;&lt;/a&gt; annotation.&lt;/p&gt;

&lt;h4 id=&#34;field&#34;&gt;Field&lt;/h4&gt;

&lt;p&gt;The &lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/annotations/Field.html
&#34;&gt;&lt;code&gt;@Field&lt;/code&gt;&lt;/a&gt; annotation defines indexing on a specific document field.  Multiple
instances of this annotation may be passed to the &lt;code&gt;@Index&lt;/code&gt; annotation to define a compound index on multiple fields.&lt;/p&gt;

&lt;h4 id=&#34;indexoptions&#34;&gt;IndexOptions&lt;/h4&gt;

&lt;p&gt;The &lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/annotations/IndexOptions.html
&#34;&gt;&lt;code&gt;@IndexOptions&lt;/code&gt;&lt;/a&gt; annotation defines the options to apply to an index
definition.  This annotation replaces the fields found directly on the &lt;code&gt;@Index&lt;/code&gt; annotation.  This annotation was added to ensure that index
options are consistent across the various index definition approaches.&lt;/p&gt;

&lt;h4 id=&#34;collation&#34;&gt;Collation&lt;/h4&gt;

&lt;p&gt;The &lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/annotations/Collation.html
&#34;&gt;&lt;code&gt;@Collation&lt;/code&gt;&lt;/a&gt; annotation defines the
&lt;a href=&#34;http://docs.mongodb.org/manual/reference/collation/
&#34;&gt;collation&lt;/a&gt; options to apply to the index definition.  In addition to defining a collation as part
of an index, a collation can be specified as part of a query as well.  The Options classes provide facilities for specifying a specific
collation to be used for any given operation.  This collation does not have to match the one defined on the index but will, of course,
be faster if it does.  See &lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/CountOptions.html
&#34;&gt;&lt;code&gt;CountOptions&lt;/code&gt;&lt;/a&gt;,
&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/DeleteOptions.html
&#34;&gt;&lt;code&gt;DeleteOptions&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/FindOptions.html
&#34;&gt;&lt;code&gt;FindOptions&lt;/code&gt;&lt;/a&gt;,
 &lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/MapReduceOptions.html
&#34;&gt;&lt;code&gt;MapReduceOptions&lt;/code&gt;&lt;/a&gt;,
 and &lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/FindAndModifyOptions.html
&#34;&gt;&lt;code&gt;FindAndModifyOptions&lt;/code&gt;&lt;/a&gt; for more information.&lt;/p&gt;

&lt;h4 id=&#34;indexed&#34;&gt;Indexed&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/annotations/Indexed.html
&#34;&gt;&lt;code&gt;@Indexed&lt;/code&gt;&lt;/a&gt;, applied to a Java field, marks the field to be indexed by MongoDB.
This is used for simple, single-field indexes.  As stated above, the &lt;code&gt;options&lt;/code&gt; value replaces the individual setting values on the
&lt;code&gt;@Indexed&lt;/code&gt; annotation itself.&lt;/p&gt;

&lt;h2 id=&#34;entity-mapping&#34;&gt;Entity Mapping&lt;/h2&gt;

&lt;p&gt;Morphia provides a number of annotations providing for the customization of object mapping.&lt;/p&gt;

&lt;h3 id=&#34;entity&#34;&gt;Entity&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/annotations/Entity.html
&#34;&gt;&lt;code&gt;@Entity&lt;/code&gt;&lt;/a&gt; marks entities to be stored directly in a collection. This annotation
is optional in most cases but is required if an entity is to be mapped to a specifically named collection.  If no mapping is given, the
collection is named after the class itself.  There are two different mechanisms for mapping cross-object relationships in Morphia:
references and embedding.&lt;/p&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/annotations/Reference.html
&#34;&gt;&lt;code&gt;@Reference&lt;/code&gt;&lt;/a&gt; marks a field as a reference to a document stored in another
collection and is linked (by a &lt;code&gt;DBRef&lt;/code&gt; field). When the Entity is loaded, the referenced entity is also be loaded.  Any object referenced
via an &lt;code&gt;@Reference&lt;/code&gt; field must have already have a non-null &lt;code&gt;@Id&lt;/code&gt; value in the referenced entity. This can be done by either saving the
referenced entities first or by manually assigning them ID values.  By default, these referenced entities are automatically loaded by
Morphia along with the referencing entity.  This can result in a high number of database round trips just to load a single entity.  To
resolve this, &lt;code&gt;lazy = true&lt;/code&gt; can be passed to the annotation.  This will create a dynamic proxy which will lazily load the entity the first
time it is referenced in code.&lt;/p&gt;

&lt;p&gt;Fields annotated with &lt;code&gt;@Reference&lt;/code&gt; will show up in MongoDB as &lt;code&gt;DBRef&lt;/code&gt; fields by default.  A &lt;code&gt;DBRef&lt;/code&gt; stores not only the entity&amp;rsquo;s ID value
but also the collection name.  In most cases, this is probably redundant information as the collection name is already encoded in the
entity&amp;rsquo;s mapping information.  To reduce the amount of storage necessary to track these references, use &lt;code&gt;idOnly = true&lt;/code&gt; in the mapping.
This will result in only the ID value being stored in the document.&lt;/p&gt;

&lt;h3 id=&#34;embedded&#34;&gt;Embedded&lt;/h3&gt;

&lt;p&gt;In contrast to &lt;code&gt;@Reference&lt;/code&gt; where a nested Java reference ends up as a separate document in a collection,
&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/annotations/Embedded.html
&#34;&gt;&lt;code&gt;@Embedded&lt;/code&gt;&lt;/a&gt; tells Morphia to embed the document created from the Java object
in the document of the parent object.  This annotation can be applied to the class of the embedded type or on the field holding the
embedded instance.&lt;/p&gt;

&lt;h3 id=&#34;validation&#34;&gt;Validation&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/annotations/Validation.html
&#34;&gt;&lt;code&gt;@Validation&lt;/code&gt;&lt;/a&gt; allows for the definition of a
&lt;a href=&#34;http://docs.mongodb.org/manual/core/document-validation/
&#34;&gt;document validation&lt;/a&gt; schema to applied to all writes to MongoDB.  Validation rules are
specified on a per-collection basis using any query operators, with the exception of &lt;code&gt;$near&lt;/code&gt;, &lt;code&gt;$nearSphere&lt;/code&gt;, &lt;code&gt;$text&lt;/code&gt;, and &lt;code&gt;$where&lt;/code&gt;.  This
validation definition is done using the MongoDB query syntax as shown here:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Validation(&amp;quot;{ number : { $gt : 10 } }&amp;quot;)
public class SomeEntity {
    ...
    private int number;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Various operations on &lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/Datastore.html
&#34;&gt;&lt;code&gt;Datastore&lt;/code&gt;&lt;/a&gt; and
&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/AdvancedDatastore.html
&#34;&gt;&lt;code&gt;AdvancedDatastore&lt;/code&gt;&lt;/a&gt; can bypass this validation via their Options classes. For
these operations, specify the &lt;code&gt;bypassDocumentValidation&lt;/code&gt; option to disable document validation for a specific operation.  See
&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/InsertOptions.html
&#34;&gt;&lt;code&gt;InsertOptions&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/UpdateOptions.html
&#34;&gt;&lt;code&gt;UpdateOptions&lt;/code&gt;&lt;/a&gt;,
&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/MapReduceOptions.html
&#34;&gt;&lt;code&gt;MapReduceOptions&lt;/code&gt;&lt;/a&gt;,
 and &lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/FindAndModifyOptions.html
&#34;&gt;&lt;code&gt;FindAndModifyOptions&lt;/code&gt;&lt;/a&gt; for more information.&lt;/p&gt;

&lt;h3 id=&#34;id&#34;&gt;Id&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/annotations/Id.html
&#34;&gt;&lt;code&gt;@Id&lt;/code&gt;&lt;/a&gt; marks a field in an entity to be the &lt;code&gt;_id&lt;/code&gt; field in MongoDB.  This
annotation is required on all top level entities regardless of the presence of an &lt;code&gt;@Entity&lt;/code&gt; annotation.  If a class is marked with
&lt;code&gt;@Embedded&lt;/code&gt; this annotation is not required since embedded documents are not required to have _id fields.&lt;/p&gt;

&lt;h3 id=&#34;property&#34;&gt;Property&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/annotations/Property.html
&#34;&gt;&lt;code&gt;@Property&lt;/code&gt;&lt;/a&gt; is an optional annotation instructing Morphia to persist the
field using the given name in the document saved in MongoDB.  By default, the field name is used as the property name.  This can be
overridden by passing a String with the new name to the annotation.&lt;/p&gt;

&lt;h3 id=&#34;transient&#34;&gt;Transient&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/annotations/Transient.html
&#34;&gt;&lt;code&gt;@Transient&lt;/code&gt;&lt;/a&gt; instructs Morphia to ignore this field when converting an
entity to a document.  The Java keyword &lt;code&gt;transient&lt;/code&gt; can also be used instead.&lt;/p&gt;

&lt;h3 id=&#34;serialized&#34;&gt;Serialized&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/annotations/Serialized.html
&#34;&gt;&lt;code&gt;@Serialized&lt;/code&gt;&lt;/a&gt; instructs Morphia to serialize this field using JDK
serialization.  The field&amp;rsquo;s value gets converted to a &lt;code&gt;byte[]&lt;/code&gt; and passed to MongoDB.&lt;/p&gt;

&lt;h3 id=&#34;notsaved&#34;&gt;NotSaved&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/annotations/NotSaved.html
&#34;&gt;&lt;code&gt;@NotSaved&lt;/code&gt;&lt;/a&gt; instructs Morphia to ignore this field when saving but will
 still be loaded from the database when the entity is read.&lt;/p&gt;

&lt;h3 id=&#34;alsoload&#34;&gt;AlsoLoad&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/annotations/AlsoLoad.html
&#34;&gt;&lt;code&gt;@AlsoLoad&lt;/code&gt;&lt;/a&gt; instructs Morphia to look for a field under different names than
the mapped name.  When a field gets remapped to a new name, you can either update the database and migrate all the fields at once or use
this annotation to tell Morphia what older names to try if the current one fails.  It is an error to have values under both the old and
new key names when loading a document.  These alternate names are not used in queries, however, so if there are queries against this field
they should be updated to use the alternate names as well or the database should be updated such that every instance of the old name is
renamed.&lt;/p&gt;

&lt;h3 id=&#34;version&#34;&gt;Version&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/annotations/Version.html
&#34;&gt;&lt;code&gt;@Version&lt;/code&gt;&lt;/a&gt; marks a field in an entity to control optimistic locking. If the
versions change in the database while modifying an entity (including deletes) a &lt;code&gt;ConcurrentModificationException&lt;/code&gt; will be thrown. This
field will be automatically managed for you &amp;ndash; there is no need to set a value and you should not do so.  If another name beside the Java
field name is desired, a name can be passed to this annotation to change the document&amp;rsquo;s field name.&lt;/p&gt;

&lt;h2 id=&#34;lifecycle-annotations&#34;&gt;Lifecycle Annotations&lt;/h2&gt;

&lt;p&gt;There are various annotations which can be used to register callbacks on certain lifecycle events. These include Pre/Post-Persist, Pre-Save, and Pre/Post-Load.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@PreLoad&lt;/code&gt; - Called before mapping the datastore object to the entity (POJO); the DBObject is passed as an argument (you can add/remove/change values)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PostLoad&lt;/code&gt; - Called after mapping to the entity&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PrePersist&lt;/code&gt; - Called before save, it can return a DBObject in place of an empty one.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PreSave&lt;/code&gt; - Called before the save call to the datastore&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PostPersist&lt;/code&gt; - Called after the save call to the datastore&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mongodb/morphia/blob/master/morphia/src/test/java/org/mongodb/morphia/TestQuery.java#L63&#34;&gt;This&lt;/a&gt; is one of the test
classes.&lt;/p&gt;

&lt;p&gt;All parameters and return values are optional in your implemented methods.&lt;/p&gt;

&lt;h4 id=&#34;prepersist&#34;&gt;&lt;code&gt;@PrePersist&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;Here is a simple example of an entity that always saves the Date it was last updated at.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class BankAccount {
  @Id String id;
  Date lastUpdated = new Date();

  @PrePersist void prePersist() {lastUpdated = new Date();}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;entitylisteners&#34;&gt;&lt;code&gt;@EntityListeners&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;In addition, you can separate the lifecycle event implementation in an external class, or many.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@EntityListeners(BackAccountWatcher.class)
public class BankAccount {
  @Id String id;
  Date lastUpdated = new Date();
}

class BankAccountWatcher{

  @PrePersist void prePersist(BankAccount act) {act.lastUpdated = new Date();}

}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Reference Guides</title>
      <link>/morphia/1.4/guides/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/morphia/1.4/guides/</guid>
      <description>

&lt;h2 id=&#34;reference-guides&#34;&gt;Reference Guides&lt;/h2&gt;

&lt;h3 id=&#34;core-guides&#34;&gt;Core Guides&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/querying/&#34;&gt;Querying&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/updating/&#34;&gt;Updating&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/aggregation/&#34;&gt;Aggregation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/annotations/&#34;&gt;Annotations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/indexing/&#34;&gt;Indexing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/lifeCycleMethods/&#34;&gt;Life Cycle Methods&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;extension-guides&#34;&gt;Extension Guides&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/jrebel/&#34;&gt;JRebel Support&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/validationExtension/&#34;&gt;Validation Extension&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Aggregation</title>
      <link>/morphia/1.4/guides/aggregation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/morphia/1.4/guides/aggregation/</guid>
      <description>

&lt;h1 id=&#34;aggregation&#34;&gt;Aggregation&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;http://docs.mongodb.org/manual/aggregation
&#34;&gt;aggregation framework&lt;/a&gt; in MongoDB allows you to define a series (called a pipeline) of
operations (called stages) against the data in a collection.  These pipelines can be used for analytics or they can be used to
convert your data from one form to another.  This guide will not go in to the details of how aggregation works, however.  The official
 MongoDB &lt;a href=&#34;http://docs.mongodb.org/manual/aggregation
&#34;&gt;documentation&lt;/a&gt; has extensive tutorials on such details.  Rather, this
 guide will
 focus on the Morphia API.  The examples shown here are taken from the &lt;a href=&#34;https://github.com/mongodb/morphia/blob/master/morphia/src/test/java/org/mongodb/morphia/aggregation/AggregationTest.java
&#34;&gt;tests&lt;/a&gt; in Morphia itself.&lt;/p&gt;

&lt;p&gt;Writing an aggregation pipeline starts just like writing a standard query.  As with querying, we start with the &lt;code&gt;Datastore&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Iterator&amp;lt;Author&amp;gt; aggregate = datastore.createAggregation(Book.class)
      .group(&amp;quot;author&amp;quot;, grouping(&amp;quot;books&amp;quot;, push(&amp;quot;title&amp;quot;)))
      .out(Author.class, options);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;createAggregation()&lt;/code&gt; takes a &lt;code&gt;Class&lt;/code&gt; literal.  This lets Morphia know which collection to perform this aggregation
against.  Because of the transformational operations available in the aggregation &lt;a href=&#34;http://docs.mongodb.org/manual/core/aggregation-pipeline
&#34;&gt;pipeline&lt;/a&gt;,
 Morphia can not validate as much as it can with querying so care will need to be taken to ensure
 document fields actually exist when referencing them in your pipeline.&lt;/p&gt;

&lt;h2 id=&#34;the-pipeline&#34;&gt;The Pipeline&lt;/h2&gt;

&lt;p&gt;Aggregation operations are comprised of a series stages.  Our example here has only one stage: &lt;code&gt;group()&lt;/code&gt;.  This method is the Morphia
equivalent of the &lt;a href=&#34;http://docs.mongodb.org/manual/reference/operator/aggregation/group/
&#34;&gt;&lt;code&gt;$group&lt;/code&gt;&lt;/a&gt; operator.  This stage, as the name
suggests, groups together documents based on the given field&amp;rsquo;s values.  In this example, we are collecting together all the books by
author.  The first parameter to &lt;code&gt;group()&lt;/code&gt; defines the &lt;code&gt;_id&lt;/code&gt; of the resulting documents.  Within this grouping, this pipeline takes the
&lt;code&gt;books&lt;/code&gt; fields for each author and extracts the &lt;code&gt;title&lt;/code&gt;.  With this grouping of data, we&amp;rsquo;re then &lt;code&gt;push()&lt;/code&gt;ing the titles in to an array
in the final document.  This example is the Morphia equivalent of an &lt;a href=&#34;http://docs.mongodb.org/manual/reference/operator/aggregation/group/#group-title-by-author
&#34;&gt;example&lt;/a&gt; found in the aggregation tutorials.  This results in a series of
 documents that look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt; { &amp;quot;_id&amp;quot; : &amp;quot;Homer&amp;quot;, &amp;quot;books&amp;quot; : [ &amp;quot;The Odyssey&amp;quot;, &amp;quot;Iliad&amp;quot; ] }
 { &amp;quot;_id&amp;quot; : &amp;quot;Dante&amp;quot;, &amp;quot;books&amp;quot; : [ &amp;quot;The Banquet&amp;quot;, &amp;quot;Divine Comedy&amp;quot;, &amp;quot;Eclogues&amp;quot; ] }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;executing-the-pipeline&#34;&gt;Executing the Pipeline&lt;/h2&gt;

&lt;p&gt;There are two basic ways to execute an aggregation pipeline:  &lt;code&gt;aggregate()&lt;/code&gt; and &lt;code&gt;out()&lt;/code&gt;.  These methods are Morphia&amp;rsquo;s cues to send the
 pipeline to MongoDB for execution.  In that regard, both are similar.  In practice, how the results are processed is even very similar.
  The differences, however, can have huge implications on the performance of your application.  &lt;code&gt;aggregate()&lt;/code&gt; by default will use the
 &amp;lsquo;inline&amp;rsquo; method for returning the aggregation results.  This approach has the same 16MB limitation that all documents in MongoDB share.
  We can changes this behavior using the &lt;a href=&#34;http://api.mongodb.org/java/3.0/com/mongodb/AggregationOptions.html&#34;&gt;&lt;code&gt;AggregationOptions&lt;/code&gt;&lt;/a&gt;
  class.  The &lt;code&gt;options&lt;/code&gt; reference we passed to &lt;code&gt;out()&lt;/code&gt; also applies to &lt;code&gt;aggregate()&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;aggregation-options&#34;&gt;Aggregation Options&lt;/h3&gt;

&lt;p&gt;There are a handful options here but there&amp;rsquo;s one that deserves some extra attention. As mentioned, the aggregation pipeline, by default,
 returns everything &amp;ldquo;inline&amp;rdquo; but as of MongoDB 2.6 you can tell the aggregation framework to return a cursor instead.  This is what the
 value of &lt;a href=&#34;http://api.mongodb.org/java/3.0/com/mongodb/AggregationOptions.html#getOutputMode--&#34;&gt;AggregationOptions#getOutputMode()&lt;/a&gt;
 determines.  By setting the output mode to &lt;code&gt;CURSOR&lt;/code&gt;, MongoDB can return a result size much larger than 16MB.  The options can also be
 configured to update the batch size or to set the time out threshold after which an aggregation will fail.  It is also possible to tell
  the aggregation framework to use disk space which allows, among other things, sorting of larger data sets than what can fit in memory
  on the server.&lt;/p&gt;

&lt;h3 id=&#34;out&#34;&gt;$out&lt;/h3&gt;

&lt;p&gt;But this example doesn&amp;rsquo;t use &lt;code&gt;aggregate()&lt;/code&gt;, of course, it uses &lt;code&gt;out()&lt;/code&gt; which gives us access to the &lt;code&gt;$out&lt;/code&gt; pipeline stage.  &lt;a href=&#34;http://docs.mongodb.org/manual/reference/operator/aggregation/out/
&#34;&gt;&lt;code&gt;$out&lt;/code&gt;&lt;/a&gt; is a new operator in MongoDB 2.6 that allows the results of a
pipeline to be stored in to a named collection.  This collection can not be sharded or a capped collection, however.  This collection,
if it does not exist, will be created upon execution of the pipeline.&lt;/p&gt;

&lt;div class=&#34;admonition important&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;important&lt;/h5&gt;
&lt;p&gt;Any existing data in the collection will be replaced by the output of the aggregation.&lt;/p&gt;

&lt;/div&gt;


&lt;p&gt;Using &lt;code&gt;out()&lt;/code&gt; is implicitly asking for the results to be returned via a cursor.  What is happening under the covers is the aggregation
framework is writing out to the collection and is done.  Morphia goes one extra step further and executes an implicit &lt;code&gt;find&lt;/code&gt; on the output
collection and returns a cursor for all the documents in the collection.  In practice, this behaves no differently than setting the
output mode to &lt;code&gt;CURSOR&lt;/code&gt; with &lt;code&gt;aggregate()&lt;/code&gt; and your application need not know the difference.  It does, of course, have an impact on your
database and any existing data.  The use of &lt;code&gt;$out&lt;/code&gt; and &lt;code&gt;out()&lt;/code&gt; can be greatly beneficial in scenarios such as precomputed aggregated
results for later retrieval.&lt;/p&gt;

&lt;h3 id=&#34;typed-results&#34;&gt;Typed Results&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;out()&lt;/code&gt; has several variants.  In this example, we&amp;rsquo;re passing in &lt;code&gt;Author.class&lt;/code&gt; which tells Morphia that we want to map each document
returned to an instance of &lt;code&gt;Author&lt;/code&gt;.  Because we&amp;rsquo;re using &lt;code&gt;out()&lt;/code&gt; instead of &lt;code&gt;aggregate()&lt;/code&gt;, Morphia will use the mapped collection for
&lt;code&gt;Author&lt;/code&gt; as the output collection for the pipeline.  If you&amp;rsquo;d like to use an alternate collection but still return a cursor of &lt;code&gt;Author&lt;/code&gt;
instances, you can use &lt;a href=&#34;/morphia/1.4/javadoc/org/mongodb/morphia/aggregation/AggregationPipeline.html#out-java
.lang.String-java.lang.Class-com.mongodb.AggregationOptions-&#34;&gt;&lt;code&gt;out(String,Class,AggregationOptions)&lt;/code&gt;&lt;/a&gt; instead.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Indexing</title>
      <link>/morphia/1.4/guides/indexing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/morphia/1.4/guides/indexing/</guid>
      <description>

&lt;h1 id=&#34;indexing&#34;&gt;Indexing&lt;/h1&gt;

&lt;p&gt;Morphia provides annotations that allow developers to define indexes for a collection to be defined alongside the other mapping data on
an entity&amp;rsquo;s source.  In addition to the familiar ascending/descending index types, Morphia and MongoDB support &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-ttl/
&#34;&gt;TTL&lt;/a&gt;, &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-text/
&#34;&gt;text&lt;/a&gt;, and &lt;a href=&#34;http://docs.mongodb.org/manual/applications/geospatial-indexes/
&#34;&gt;geospatial&lt;/a&gt;
 indexes.   When defining &lt;a href=&#34;#text-indexing&#34;&gt;text&lt;/a&gt; indexes there are certain restrictions which will be covered below.  Full
  details for all these types are available in the &lt;a href=&#34;http://docs.mongodb.org/manual/indexes
&#34;&gt;manual&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There are two ways to define indexes:  at the class level and at the field level.&lt;/p&gt;

&lt;h2 id=&#34;class-level-indexes&#34;&gt;Class Level Indexes&lt;/h2&gt;

&lt;p&gt;Class level indexing begins with the &lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/annotations/#indexes&#34;&gt;&lt;code&gt;@Indexes&lt;/code&gt;&lt;/a&gt; annotation.  This is a container
annotation whose sole purpose is to hold a number of &lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/annotations/#index&#34;&gt;&lt;code&gt;@Index&lt;/code&gt;&lt;/a&gt; annotations.  This annotation
has two primary components to cover here:  &lt;code&gt;fields&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt;.  An index definition would take the following form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Entity
@Indexes({
    @Index(fields = @Field(&amp;quot;field2&amp;quot;, type = DESC)),
    @Index(fields = @Field(&amp;quot;field3&amp;quot;, options = @IndexOptions(name = &amp;quot;indexing_test&amp;quot;)))
})
public class IndexExample {
    @Id
    private ObjectId id;
    private String field;
    @Property
    private String field2;
    @Property(&amp;quot;f3&amp;quot;)
    private String field3;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fields&#34;&gt;Fields&lt;/h3&gt;

&lt;p&gt;The fields to use in an index definition are defined with the &lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/annotations/#field&#34;&gt;&lt;code&gt;@Field&lt;/code&gt;&lt;/a&gt; annotation. An
arbitrary number of &lt;code&gt;@Field&lt;/code&gt;s can be given but at least one must be present.&lt;/p&gt;

&lt;h4 id=&#34;value&#34;&gt;value()&lt;/h4&gt;

&lt;p&gt;Indicates which field to use for indexing.  The name used for the field can be either the Java field name or the mapped document field
name as defined in the class&amp;rsquo;s mapping via, e.g.,  the &lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/annotations/#property&#34;&gt;&lt;code&gt;@Property&lt;/code&gt;&lt;/a&gt; or
 &lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/annotations/#embedded&#34;&gt;&lt;code&gt;@Embedded&lt;/code&gt;&lt;/a&gt; annotations.  For most index types, this value is validated by default.  An
  exception is made for &lt;a href=&#34;#text-indexing&#34;&gt;text indexes&lt;/a&gt; as discussed below.&lt;/p&gt;

&lt;h4 id=&#34;type&#34;&gt;type()&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Default: IndexType.ASC&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Indicates the &amp;ldquo;type&amp;rdquo; of the index (ascending, descending, geo2D, geo2d sphere, or text) to create on the field.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;See &lt;a href=&#34;/morphia/1.4/javadoc/org/mongodb/morphia/utils/IndexType.html&#34;&gt;IndexType&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;weight&#34;&gt;weight()&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Optional&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Specifies the weight to use when creating a text index.  This value only makes sense when direction is &lt;code&gt;IndexType.TEXT&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;index-options&#34;&gt;Index Options&lt;/h3&gt;

&lt;p&gt;Options for an index are defined on the &lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/annotations/#indexoptions&#34;&gt;&lt;code&gt;@IndexOptions&lt;/code&gt;&lt;/a&gt;.  More complete coverage can
be found in the &lt;a href=&#34;http://docs.mongodb.org/manual/reference/method/db.collection.createIndex/#options
&#34;&gt;manual&lt;/a&gt; but we&amp;rsquo;ll provide some basic coverage
here as well.&lt;/p&gt;

&lt;h4 id=&#34;background&#34;&gt;background()&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Default: false&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This value determines if the index build is a blocking call or not.  By default, creating an index blocks all other operations on a
database.  When building an index on a collection, the database that holds the collection is unavailable for read or write operations
until the index build completes. For potentially long running index building operations, consider the &lt;strong&gt;background&lt;/strong&gt; operation so that the
MongoDB database remains available during the index building operation.  The MongoDB &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-creation/#background-construction
&#34;&gt;manual&lt;/a&gt; has more detail.&lt;/p&gt;

&lt;h4 id=&#34;disablevalidation&#34;&gt;disableValidation()&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Default: false&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;When ensuring indexes in the database, Morphia will attempt to ensure that the field names match either the Java field names or the
mapped document names.  Setting this to &lt;code&gt;true&lt;/code&gt; disables this validation.&lt;/p&gt;

&lt;h4 id=&#34;dropdups&#34;&gt;dropDups()&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Default: false&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;When defining a &lt;a href=&#34;#unique&#34;&gt;unique&lt;/a&gt; index, if there are duplicate values found, the index creation will.  Setting this value to
true will instruct MongoDB to drop the documents with duplicate values.&lt;/p&gt;

&lt;div class=&#34;admonition important&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;important&lt;/h5&gt;
&lt;p&gt;As of MongoDB version 3.0, the dropDups option is no longer available.&lt;/p&gt;

&lt;/div&gt;


&lt;h4 id=&#34;expireafterseconds&#34;&gt;expireAfterSeconds()&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Optional&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Specifies a value, in seconds, as a &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-ttl/
&#34;&gt;TTL&lt;/a&gt; to control how long MongoDB retains documents in
this collection.  The field listed must contain values that are dates.&lt;/p&gt;

&lt;h4 id=&#34;language&#34;&gt;language()&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Optional&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;For &lt;a href=&#34;#text-indexing&#34;&gt;text indexes&lt;/a&gt;, the language that determines the list of stop words and the rules for the stemmer and
tokenizer. See &lt;a href=&#34;http://docs.mongodb.org/manual/reference/text-search-languages/
&#34;&gt;Text Search Languages&lt;/a&gt; for the available languages and &lt;a href=&#34;http://docs.mongodb.org/manual/tutorial/specify-language-for-text-index
&#34;&gt;Specify a
Language for Text Index&lt;/a&gt; for more information and examples. The default value
 is &lt;strong&gt;english&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&#34;languageoverride&#34;&gt;languageOverride()&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Optional&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;For &lt;a href=&#34;#text-indexing&#34;&gt;text indexes&lt;/a&gt;, the name of the field in the collection’s documents that contains the
override language for the document. The default value is &lt;strong&gt;language&lt;/strong&gt;. See &lt;a href=&#34;http://docs.mongodb.org/manual/tutorial/specify-language-for-text-index/#specify-language-field-text-index-example
&#34;&gt;Use any Field to Specify the Language for a Document&lt;/a&gt; for an example.&lt;/p&gt;

&lt;h4 id=&#34;name&#34;&gt;name()&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Optional&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The name of the index. If unspecified, MongoDB generates an index name by concatenating the names of the indexed fields and
the sort order.&lt;/p&gt;

&lt;p&gt;Whether user specified or MongoDB generated, index names including their full namespace (i.e. database.collection) cannot be longer than
 the &lt;a href=&#34;http://docs.mongodb.org/manual/reference/limits/#Index-Name-Length
&#34;&gt;Index Name Limit&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;sparse&#34;&gt;sparse()&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Default: false&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If &lt;code&gt;true&lt;/code&gt;, the index only references documents with the specified field. These indexes use less space but behave differently in
some situations (particularly sorts).  See &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-sparse/
&#34;&gt;Sparse Indexes&lt;/a&gt; for more
information.&lt;/p&gt;

&lt;h4 id=&#34;unique&#34;&gt;unique()&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Default: false&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Creates a unique index so that the collection will not accept insertion of documents where the index key or keys match an
existing value in the index.  Specify &lt;code&gt;true&lt;/code&gt; to create a unique index.&lt;/p&gt;

&lt;h4 id=&#34;partialfilter&#34;&gt;partialFilter()&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Optional&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;New in MongoDB 3.2, &lt;a href=&#34;https://docs.mongodb.com/v3.2/core/index-partial/&#34;&gt;partial indexes&lt;/a&gt; only index the documents in a collection that meet
 a specified filter expression thereby reducing storage and maintenance costs.  A partial filter is defined using a query as shown here:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Indexes({@Index(options = @IndexOptions(partialFilter = &amp;quot;{ name : { $exists : true } }&amp;quot;),
        fields = {@Field(value = &amp;quot;name&amp;quot;)})})
    public static class SomeClass { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;collation&#34;&gt;collation()&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Optional&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Collation allows users to specify language-specific rules for string comparison, such as rules for lettercase and accent marks.  A collation
can be defined using the &lt;code&gt;collation()&lt;/code&gt; property on &lt;code&gt;@IndexOptions&lt;/code&gt; and takes an &lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/annotations/#collation&#34;&gt;&lt;code&gt;@Collation&lt;/code&gt;&lt;/a&gt;
instance.&lt;/p&gt;

&lt;h2 id=&#34;field-level-indexes&#34;&gt;Field Level Indexes&lt;/h2&gt;

&lt;p&gt;Field level indexing is a simpler approach to defining a basic, single key index.  These indexes are defined by applying the
&lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/annotations/#indexed&#34;&gt;&lt;code&gt;@Indexed&lt;/code&gt;&lt;/a&gt; annotation to a particular field on a class.  Because the index definition is
applied at the field level, the index is created using only that field and so the &lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/annotations/#field&#34;&gt;&lt;code&gt;@Field&lt;/code&gt;&lt;/a&gt;
annotations are unnecessary.  The options for the index are the same as defined &lt;a href=&#34;#options&#34;&gt;above&lt;/a&gt;.  A field level index
definition would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Entity
private class FieldIndex {
    @Id
    private ObjectId id;
    @Indexed(options = @IndexOptions(unique = true))
    private String name;
    private String color;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;text-indexing&#34;&gt;Text Indexing&lt;/h2&gt;

&lt;p&gt;Morphia&amp;rsquo;s indexing supports MongoDB&amp;rsquo;s text indexing and search functionality as we&amp;rsquo;ve briefly seen above.  Full details can be found in
the &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-text/
&#34;&gt;manual&lt;/a&gt; but there are a few Morphia specific details to cover.  Indexed field names are validated
by default but validation is disabled when an index is defined using MongoDB&amp;rsquo;s
&lt;a href=&#34;http://docs.mongodb.org/manual/core/index-text/#text-index-wildcard
&#34;&gt;&lt;code&gt;$**&lt;/code&gt;&lt;/a&gt; syntax.  This special instruction tells MongoDB to create a text index on
all fields with string content in a document.  A &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-text/#compound-index
&#34;&gt;compound index&lt;/a&gt; can be created
incorporating a text index but it&amp;rsquo;s important to note there can only be one text index on a collection.&lt;/p&gt;

&lt;p&gt;A wild card text index declaration would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @Indexes(@Index(fields = @Field(value = &amp;quot;$**&amp;quot;, type = TEXT)))
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition important&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;important&lt;/h5&gt;
&lt;p&gt;A collection can have at most one text index.&lt;/p&gt;

&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>JRebel</title>
      <link>/morphia/1.4/guides/jrebel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/morphia/1.4/guides/jrebel/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This is a simple extension to Morphia to allow classes to be re-mapped once they are reloaded by JRebel.&lt;/p&gt;

&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;

&lt;p&gt;Of course you need to run JRebel (&lt;a href=&#34;http://zeroturnaround.com&#34;&gt;http://zeroturnaround.com&lt;/a&gt;) for this extension to be useful.
On top of that, you need to tell JRebel about the Plugin. In order to do that, add the following two new Elements to the VM startup command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-Drebel.morphia=true -Drebel.plugins=/path/to/morphia-jrebel-plug-1.0-SNAPSHOT.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you´re using Eclipse with the JRebel Plugin this can be skipped and instead configured in the Agent Settings GUI.
- Choose Window-&amp;gt;Prefs-&amp;gt;JRebel
- Click Agent Settings
- Choose Plugins Tab
- Click custom plugins
- add the plugin jar, OK
- Choose custom, add key &amp;ldquo;rebel.morphia&amp;rdquo; with value of &amp;ldquo;true&amp;rdquo;&lt;/p&gt;

&lt;h1 id=&#34;using&#34;&gt;Using&lt;/h1&gt;

&lt;p&gt;Register the Extension to your Morphia instance&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new JRebelExtension(morphia);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h2&gt;

&lt;h3 id=&#34;maven&#34;&gt;Maven&lt;/h3&gt;

&lt;p&gt;If you use Maven to manage your project, you can reference the Extension as a dependency:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mongodb.morphia&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;morphia-jrebel-plug&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.4.0-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Life Cycle Methods</title>
      <link>/morphia/1.4/guides/lifeCycleMethods/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/morphia/1.4/guides/lifeCycleMethods/</guid>
      <description>

&lt;h1 id=&#34;life-cycle-methods&#34;&gt;Life Cycle Methods&lt;/h1&gt;

&lt;p&gt;There are various annotations which can be used to register callbacks on certain life cycle events. These include Pre/Post-Persist (Save)
, and Pre/Post-Load.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@PrePersist&lt;/code&gt; - Called before save, it can return a &lt;code&gt;DBObject&lt;/code&gt; in place of an empty one.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PreSave&lt;/code&gt; - Called right before &lt;code&gt;DBCollection.save()&lt;/code&gt; is called. Changes made to the entity will not be persisted; the &lt;code&gt;DBObject&lt;/code&gt; can
be passed as an argument (you can add/remove/change values)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PostPersist&lt;/code&gt; - Called after the save call to the database&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PreLoad&lt;/code&gt; - Called before mapping the document from the database to the entity; the DBObject is passed as an argument (you can
add/remove/change values)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PostLoad&lt;/code&gt; - Called after populating the entity with the values from the document&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See the &lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/annotations/&#34;&gt;annotations guide&lt;/a&gt; for a full list of the annotations supported.&lt;/p&gt;

&lt;h2 id=&#34;examples&#34;&gt;Examples&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mongodb/morphia/blob/master/morphia/src/test/java/org/mongodb/morphia/TestQuery.java#L63&#34;&gt;Here&lt;/a&gt; is a one of the test classes.&lt;/p&gt;

&lt;p&gt;All parameters and return values are options in your implemented methods.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Here is a simple example of an entity that always saves the Date it was last updated.  Alternatively, the resulting serialized form can
be passed back in just prior to sending the document to the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class BankAccount {
  @Id
  String id;
  Date lastUpdated = new Date();

  @PrePersist
  public void trackUpdate() {
    lastUpdated = new Date();
  }

  @PrePersist
  public void prePersist(final DBObject dbObj) {
    // perform operations on serialized form of the entity
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;entitylisteners&#34;&gt;EntityListeners&lt;/h3&gt;

&lt;p&gt;If your application has more generalized life cycle events, these methods can be stored on classes external to your model.  For example&amp;rsquo;s
 sake, let&amp;rsquo;s assume there&amp;rsquo;s a need to digitally sign all documents before storing it in the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@EntityListeners(DigitalSigner.class)
public class BankAccount {
  @Id
  String id;
  Date lastUpdated = new Date();
}

class DigitalSigner {
  @PrePersist
  void prePersist(final Object entity, final DBObject dbObject) {
     dbObject.put(&amp;quot;signature&amp;quot;, sign(dbObject));
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;no-delete-support&#34;&gt;No Delete Support&lt;/h2&gt;

&lt;p&gt;Because deletes are usually done with queries there is no way to support a Delete lifecycle event. If, or when, server-side triggers are enabled there may be some support for this, but even then it will be hard to imagine how this would logically fit.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Querying</title>
      <link>/morphia/1.4/guides/querying/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/morphia/1.4/guides/querying/</guid>
      <description>

&lt;h1 id=&#34;querying&#34;&gt;Querying&lt;/h1&gt;

&lt;p&gt;Morphia offers a fluent API with which to build up a query and map the results back to instances of your entity classes.  It attempts
 to provide as much type safety and validation as possible.  To this end, Morphia offers the &lt;code&gt;Query&amp;lt;T&amp;gt;&lt;/code&gt; class which can be parameterized to
the type of your entity.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-query&#34;&gt;Creating a Query&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Datastore&lt;/code&gt; is the key class when using Morphia.  Virtually all operations begin with the &lt;code&gt;Datastore&lt;/code&gt;.  To create the &lt;code&gt;Query&lt;/code&gt;, we
invoke the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Query&amp;lt;Product&amp;gt; query = datastore.createQuery(Product.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;createQuery()&lt;/code&gt; returns an instance of &lt;code&gt;Query&lt;/code&gt; with which we can build a query.&lt;/p&gt;

&lt;h3 id=&#34;filter&#34;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The first method of interest is &lt;code&gt;filter()&lt;/code&gt;.  This method takes two values: a condition string and a value.  The &lt;code&gt;value&lt;/code&gt; parameter is, of
course, the value to use when applying the &lt;code&gt;condition&lt;/code&gt; clause.  The &lt;code&gt;condition&lt;/code&gt; parameter is a bit more complicated.  At its simplest,
the condition is just a field name.  In this case, the condition is assumed to be an &lt;a href=&#34;http://docs.mongodb.org/manual/reference/operator/query/eq/
&#34;&gt;equality&lt;/a&gt; check.  There is a slightly more complicated variant, however.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;condition&lt;/code&gt; value can also contain an operator.  For example, to compare a numeric field against a value, you might write something
like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;query.filter(&amp;quot;price &amp;gt;=&amp;quot;, 1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, we&amp;rsquo;re instructing Morphia to add a filter using &lt;a href=&#34;http://docs.mongodb.org/manual/reference/operator/query/gte/
&#34;&gt;$gte&lt;/a&gt;.  This would result
 in a query that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{ price: { $gte: 1000 } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The list of supported filter operations can be found in the &lt;a href=&#34;https://github.com/mongodb/morphia/blob/master/morphia/src/main/java/org/mongodb/morphia/query/FilterOperator.java
&#34;&gt;FilterOperator&lt;/a&gt; class.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operator&lt;/th&gt;
&lt;th&gt;Alias&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$center&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$centerSphere&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$box&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$eq&lt;/td&gt;
&lt;td&gt;=, ==&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$ne&lt;/td&gt;
&lt;td&gt;!=, &amp;lt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$gt&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$gte&lt;/td&gt;
&lt;td&gt;&amp;gt;=&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$lt&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$lte&lt;/td&gt;
&lt;td&gt;&amp;lt;=&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$exists&lt;/td&gt;
&lt;td&gt;exists&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$type&lt;/td&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$not&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$mod&lt;/td&gt;
&lt;td&gt;mod&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$size&lt;/td&gt;
&lt;td&gt;size&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$in&lt;/td&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$nin&lt;/td&gt;
&lt;td&gt;nin&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$all&lt;/td&gt;
&lt;td&gt;all&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$elemMatch&lt;/td&gt;
&lt;td&gt;elem, elemMatch&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$where&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$near&lt;/td&gt;
&lt;td&gt;near&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$nearSphere&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$within (deprecated replaced by $geoWithin)&lt;/td&gt;
&lt;td&gt;within&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$geoNear&lt;/td&gt;
&lt;td&gt;geoNear&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$geoWithin&lt;/td&gt;
&lt;td&gt;geoWithin&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$geoIntersects&lt;/td&gt;
&lt;td&gt;geoIntersects&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Each filter operator can either be referenced by its MongoDB &amp;ldquo;dollar operator&amp;rdquo; or by the aliases listed afterward.  For example, with
 the equal operator, you can use the canonical &lt;code&gt;$eq&lt;/code&gt; operator as you would when building a query in the shell or you could opt to use
 either the &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;==&lt;/code&gt; aliases which might feel a little more natural to use than the dollar operators.&lt;/p&gt;

&lt;h3 id=&#34;field&#34;&gt;&lt;code&gt;field()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;For those who would prefer more compile time validation of their queries, there is &lt;code&gt;field()&lt;/code&gt;.  This method takes only the field name and
returns an instance of a &lt;a href=&#34;https://github.com/mongodb/morphia/blob/master/morphia/src/main/java/org/mongodb/morphia/query/FieldEnd.java
&#34;&gt;class&lt;/a&gt; providing methods with which
 to define your filters.  This approach is slightly more verbose but can be validated by the compiler to a much greater degree than
 &lt;code&gt;filter()&lt;/code&gt; can be.  To perform the same query as above, you&amp;rsquo;d write this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;query.field(&amp;quot;price&amp;quot;).greaterThanOrEq(1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This results in the exact same query as the &lt;code&gt;filter()&lt;/code&gt; version but has the advantage that any typo in the operation name (method in this
case) would easily be caught by an IDE or compiler.  Which version you use is largely a question of preference.&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
&lt;p&gt;Regardless of the approach used, the field name given can be either the Java field name or the document field name as defined by the
&lt;code&gt;@Property&lt;/code&gt; annotation on the field.  Morphia will normalize the name and validate the name such that a query with a bad field name will
result in an error.&lt;/p&gt;

&lt;/div&gt;


&lt;h2 id=&#34;complex-queries&#34;&gt;Complex Queries&lt;/h2&gt;

&lt;p&gt;Of course, queries are usually more complex than single field comparisons.  Morphia offers both &lt;code&gt;and()&lt;/code&gt; and &lt;code&gt;or()&lt;/code&gt; to build up more
complex queries.  An &lt;code&gt;and&lt;/code&gt; query might look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;q.and(
    q.criteria(&amp;quot;width&amp;quot;).equal(10),
    q.criteria(&amp;quot;height&amp;quot;).equal(1)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An &lt;code&gt;or&lt;/code&gt; clause looks exactly the same except for using &lt;code&gt;or()&lt;/code&gt; instead of &lt;code&gt;and()&lt;/code&gt;, of course.  For these clauses we use the &lt;code&gt;criteria()&lt;/code&gt;
method instead of &lt;code&gt;field()&lt;/code&gt; but it is used in much the same fashion.  &lt;code&gt;and()&lt;/code&gt; and &lt;code&gt;or()&lt;/code&gt; take a &lt;a href=&#34;https://docs.oracle
.com/javase/8/docs/technotes/guides/language/varargs.html&#34;&gt;&lt;code&gt;varargs&lt;/code&gt;&lt;/a&gt; parameter of type &lt;code&gt;Criteria&lt;/code&gt; so you can include as many filters as necessary.
 If all you need is an &lt;code&gt;and&lt;/code&gt; clause, you don&amp;rsquo;t need an explicit call to &lt;code&gt;and()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;datastore.createQuery(UserLocation.class)
    .field(&amp;quot;x&amp;quot;).lessThan(5)
    .field(&amp;quot;y&amp;quot;).greaterThan(4)
    .field(&amp;quot;z&amp;quot;).greaterThan(10);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This generates an implicit &lt;code&gt;and&lt;/code&gt; across the field comparisons.&lt;/p&gt;

&lt;h2 id=&#34;text-searching&#34;&gt;Text Searching&lt;/h2&gt;

&lt;p&gt;Morphia also supports MongoDB&amp;rsquo;s text search capabilities.  In order to execute a text search against a collection, the collection must
have a &lt;a href=&#34;http://docs.mongodb.org/manual//core/index-text/
&#34;&gt;text index&lt;/a&gt; defined first.  Using Morphia that definition would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Indexes(@Index(fields = @Field(value = &amp;quot;$**&amp;quot;, type = IndexType.TEXT)))
public static class Greeting {
    @Id
    private ObjectId id;
    private String value;
    private String language;

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;$**&lt;/code&gt; value tells MongoDB to create a text index on all the text fields in a document.  A more targeted index can be created, if
desired, by explicitly listing which fields to index.  Once the index is defined, we can start querying against it like this &lt;a href=&#34;https://github.com/mongodb/morphia/blob/master/morphia/src/test/java/org/mongodb/morphia/query/TestTextSearching.java
&#34;&gt;test&lt;/a&gt; does:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;morphia.map(Greeting.class);
datastore.ensureIndexes();

datastore.save(new Greeting(&amp;quot;good morning&amp;quot;, &amp;quot;english&amp;quot;),
    new Greeting(&amp;quot;good afternoon&amp;quot;, &amp;quot;english&amp;quot;),
    new Greeting(&amp;quot;good night&amp;quot;, &amp;quot;english&amp;quot;),
    new Greeting(&amp;quot;good riddance&amp;quot;, &amp;quot;english&amp;quot;),
    new Greeting(&amp;quot;guten Morgen&amp;quot;, &amp;quot;german&amp;quot;),
    new Greeting(&amp;quot;guten Tag&amp;quot;, &amp;quot;german&amp;quot;)),
    new Greeting(&amp;quot;gute Nacht&amp;quot;, &amp;quot;german&amp;quot;));

List&amp;lt;Greeting&amp;gt; good = datastore.createQuery(Greeting.class)
                             .search(&amp;quot;good&amp;quot;)
                             .order(&amp;quot;_id&amp;quot;)
                             .asList();
Assert.assertEquals(4, good.size());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see here, we create &lt;code&gt;Greeting&lt;/code&gt; objects for multiple languages.  In our test query, we&amp;rsquo;re looking for occurrences of the word
&amp;ldquo;good&amp;rdquo; in any document.  We created four such documents and our query returns exactly those four.&lt;/p&gt;

&lt;h2 id=&#34;other-query-options&#34;&gt;Other Query Options&lt;/h2&gt;

&lt;p&gt;There is more to querying than simply filtering against different document values.  Listed below are some of the options for modifying
the query results in different ways.&lt;/p&gt;

&lt;h3 id=&#34;projections&#34;&gt;Projections&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.mongodb.org/manual/tutorial/project-fields-from-query-results/
&#34;&gt;Projections&lt;/a&gt; allow you to return only a subset of the fields in a
document.  This is useful when you need to only return a smaller view of a larger object.  Borrowing from the &lt;a href=&#34;https://github.com/mongodb/morphia/blob/master/morphia/src/test/java/org/mongodb/morphia/TestQuery.java
&#34;&gt;unit tests&lt;/a&gt;, this is an example of this feature in action:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ContainsRenamedFields user = new ContainsRenamedFields(&amp;quot;Frank&amp;quot;, &amp;quot;Zappa&amp;quot;);
getDs().save(user);

ContainsRenamedFields found = getDs()
    .find(ContainsRenamedFields.class)
    .project(&amp;quot;first_name&amp;quot;, true)
    .get();
Assert.assertNotNull(found.firstName);
Assert.assertNull(found.lastName);

found = getDs()
    .find(ContainsRenamedFields.class)
    .project(&amp;quot;firstName&amp;quot;, true)
    .get();
Assert.assertNotNull(found.firstName);
Assert.assertNull(found.lastName);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see here, we&amp;rsquo;re saving this entity with a first and last name but our query only returns the first name (and the _id value) in
 the returned instance of our type.  It&amp;rsquo;s also worth noting that this project works with both the mapped document field name
 &lt;code&gt;&amp;quot;first_name&amp;quot;&lt;/code&gt; and the Java field name &lt;code&gt;&amp;quot;firstName&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The boolean value passed in instructs Morphia to either include (&lt;code&gt;true&lt;/code&gt;) or exclude (&lt;code&gt;false&lt;/code&gt;) the field.  It is not currently possible to list both inclusions and exclusions in one query.&lt;/p&gt;

&lt;div class=&#34;admonition important&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;important&lt;/h5&gt;
&lt;p&gt;While projections can be a nice performance win in some cases, it&amp;rsquo;s important to note that this object can not be safely saved back to
 MongoDB.  Any fields in the existing document in the database that are missing from the entity will be removed if this entity is
  saved. For example, in the example above if &lt;code&gt;found&lt;/code&gt; is saved back to MongoDB, the &lt;code&gt;last_name&lt;/code&gt; field that currently exists in the database
  for this entity will be removed.  To save such instances back consider using &lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/Datastore#merge-T-.html&#34;&gt;&lt;code&gt;Datastore#merge(T)&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;


&lt;h3 id=&#34;limiting-and-skipping&#34;&gt;Limiting and Skipping&lt;/h3&gt;

&lt;p&gt;Pagination of query results is often done as a combination of skips and limits.  Morphia offers &lt;code&gt;Query.limit(int)&lt;/code&gt; and &lt;code&gt;Query.offset(int)&lt;/code&gt;
for these cases.  An example of these methods in action would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;datastore.createQuery(Person.class)
    .asList(new FindOptions()
	    .offset(1)
	    .limit(10))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This query will skip the first element and take up to the next 10 items found by the query.  There&amp;rsquo;s a caveat to using skip/limit for
pagination, however.  See the &lt;a href=&#34;http://docs.mongodb.org/manual/reference/method/cursor.skip
&#34;&gt;skip&lt;/a&gt; documentation for more detail.&lt;/p&gt;

&lt;h3 id=&#34;ordering&#34;&gt;Ordering&lt;/h3&gt;

&lt;p&gt;Ordering the results of a query is done via &lt;a href=&#34;/morphia/1.4/javadoc/org/mongodb/morphia/query/Query.html#order-java.lang.String-&#34;&gt;&lt;code&gt;Query.order(String)&lt;/code&gt;&lt;/a&gt;
.  The javadoc has complete examples but this String consists of a list of comma delimited fields to order by.  To reverse the sort order
 for a particular field simply prefix that field with a &lt;code&gt;-&lt;/code&gt;.  For example, to sort by age (youngest to oldest) and then income (highest
 to lowest), you would use this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;query.order(&amp;quot;age,-income&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tailable-cursors&#34;&gt;Tailable Cursors&lt;/h3&gt;

&lt;p&gt;If you have a &lt;a href=&#34;http://docs.mongodb.org/manual/core/capped-collections/
&#34;&gt;capped collection&lt;/a&gt; it&amp;rsquo;s possible to &amp;ldquo;tail&amp;rdquo; a query so that when new documents
are added to the collection that match your query, they&amp;rsquo;ll be returned by the &lt;a href=&#34;http://docs.mongodb.org/manual/reference/glossary/#term-tailable-cursor
&#34;&gt;tailable cursor&lt;/a&gt;.  An example of this feature in action can be found in the &lt;a href=&#34;https://github.com/mongodb/morphia/blob/master/morphia/src/test/java/org/mongodb/morphia/TestQuery.java
&#34;&gt;unit tests&lt;/a&gt; in the &lt;code&gt;testTailableCursors()&lt;/code&gt; test:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;getMorphia().map(CappedPic.class);
getDs().ensureCaps();                                                          // #1
final Query&amp;lt;CappedPic&amp;gt; query = getDs().createQuery(CappedPic.class);
final List&amp;lt;CappedPic&amp;gt; found = new ArrayList&amp;lt;CappedPic&amp;gt;();

final Iterator&amp;lt;CappedPic&amp;gt; tail = query
	.fetch(new FindOptions()
		.cursorType(CursorType.Tailable));
while(found.size() &amp;lt; 10) {
	found.add(tail.next());                                                    // #2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two things to note about this code sample:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;This tells Morphia to make sure that any entity &lt;a href=&#34;/morphia/1.4/guides/annotations/#entity&#34;&gt;configured&lt;/a&gt; to use a capped collection has its collection
created correctly.  If the collection already exists and is not capped, you will have to manually &lt;a href=&#34;http://docs.mongodb.org/manual/core/capped-collections/#convert-a-collection-to-capped
&#34;&gt;update&lt;/a&gt; your collection to be a capped collection.&lt;/li&gt;
&lt;li&gt;Since this &lt;code&gt;Iterator&lt;/code&gt; is backed by a tailable cursor, &lt;code&gt;hasNext()&lt;/code&gt; and &lt;code&gt;next()&lt;/code&gt; will block until a new item is found.  In this
version of the unit test, we tail the cursor waiting to pull out objects until we have 10 of them and then proceed with the rest of the
application.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;raw-querying&#34;&gt;Raw Querying&lt;/h3&gt;

&lt;p&gt;You can use Morphia to map queries you might have already written using the raw Java API against your objects, or to access features which are not yet present in Morphia.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DBObject query = BasicDBObjectBuilder.start()
	.add(&amp;quot;albums&amp;quot;,
            new BasicDBObject(&amp;quot;$elemMatch&amp;quot;,
                    new BasicDBObject(&amp;quot;$and&amp;quot;, new BasicDBObject[] {
                        new BasicDBObject(&amp;quot;albumId&amp;quot;, albumDto.getAlbumId()),
                        new BasicDBObject(&amp;quot;album&amp;quot;,
                            new BasicDBObject(&amp;quot;$exists&amp;quot;, false))})))
	.get();

Artist result = datastore.createQuery(Artist.class, query).get();
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Updating</title>
      <link>/morphia/1.4/guides/updating/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/morphia/1.4/guides/updating/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;There are two basic ways to update your data: insert/save a whole Entity or issue an update operation.&lt;/p&gt;

&lt;h1 id=&#34;updating-on-the-server&#34;&gt;Updating (on the server)&lt;/h1&gt;

&lt;p&gt;The update method on &lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/Datastore.html
&#34;&gt;&lt;code&gt;Datastore&lt;/code&gt;&lt;/a&gt; is used to issue a command to the server to change
existing documents.  The effects of the update command are defined via
&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/query/UpdateOperations.html
&#34;&gt;&lt;code&gt;UpdateOperations&lt;/code&gt;&lt;/a&gt; methods.&lt;/p&gt;

&lt;h2 id=&#34;the-field-expression&#34;&gt;The Field Expression&lt;/h2&gt;

&lt;p&gt;The field expression, used by all update operations,  can be either a single field name or any dot-notation form (for embedded
elements). The positional operator ($) can also be used in the in the field expression for array updates.  To illustrate, consider the
entity here:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Entity(&amp;quot;hotels&amp;quot;)
public class Hotel
{
   @Id
   private ObjectId id;

   private String name;
   private int stars;

   @Embedded
   private Address address;

   List&amp;lt;Integer&amp;gt; roomNumbers = new ArrayList&amp;lt;Integer&amp;gt;();

   // ... optional getters and setters
}

@Embedded
public class Address
{
   private String street;
   private String city;
   private String postalCode;
   private String country;

   // ... optional getters and setters
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;set-unset&#34;&gt;set()/unset()&lt;/h3&gt;

&lt;p&gt;To change the name of the hotel, one would use something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;UpdateOperations ops = datastore
    .createUpdateOperations(Hotel.class)
    .set(&amp;quot;name&amp;quot;, &amp;quot;Fairmont Chateau Laurier&amp;quot;);
datastore.update(updateQuery, ops);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This also works for embedded documents.  To change the name of the city in the address, one would use something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;UpdateOperations ops = datastore
    .createUpdateOperations(Hotel.class)
    .set(&amp;quot;address.city&amp;quot;, &amp;quot;Ottawa&amp;quot;);
datastore.update(updateQuery, ops);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Values can also be removed from documents as shown below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;UpdateOperations ops = datastore
    .createUpdateOperations(Hotel.class)
    .unset(&amp;quot;name&amp;quot;);
datastore.update(updateQuery, ops);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this update, the name of the hotel would be &lt;code&gt;null&lt;/code&gt; when the entity is loaded.&lt;/p&gt;

&lt;h3 id=&#34;inc-dec&#34;&gt;inc()/dec()&lt;/h3&gt;

&lt;p&gt;To simply increment or decrement values in the database, updates like these would be used:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// increment &#39;stars&#39; by 4
UpdateOperations ops = datastore
    .createUpdateOperations(Hotel.class)
    .inc(&amp;quot;stars&amp;quot;);
datastore.update(updateQuery, ops);

// increment &#39;stars&#39; by 4
ops = datastore
    .createUpdateOperations(Hotel.class)
    .inc(&amp;quot;stars&amp;quot;, 4);
datastore.update(updateQuery, ops);

// decrement &#39;stars&#39; by 1
ops = datastore
    .createUpdateOperations(Hotel.class)
    .dec(&amp;quot;stars&amp;quot;);  // same as .inc(&amp;quot;stars&amp;quot;, -1)
datastore.update(updateQuery, ops);

// decrement &#39;stars&#39; by 4
ops = datastore
    .createUpdateOperations(Hotel.class)
    .inc(&amp;quot;stars&amp;quot;, -4);
datastore.update(updateQuery, ops);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;push-addtoset&#34;&gt;push()/addToSet()&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;push()&lt;/code&gt; is used to add a value to an array field:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ops = datastore
    .createUpdateOperations(Hotel.class)
    .push(&amp;quot;roomNumbers&amp;quot;, 11);
datastore.update(updateQuery, ops);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will issue a &lt;code&gt;$push&lt;/code&gt; operation adding &lt;code&gt;11&lt;/code&gt; to the list.  This might result in duplicated values in this field.  If the values should
be unique, use &lt;code&gt;addToSet()&lt;/code&gt; instead:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ops = datastore
    .createUpdateOperations(Hotel.class)
    .addToSet(&amp;quot;roomNumbers&amp;quot;, 11);
datastore.update(updateQuery, ops);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;push()&lt;/code&gt; and &lt;code&gt;addToSet()&lt;/code&gt; can take either single values or a &lt;code&gt;List&lt;/code&gt; of values.  The &lt;code&gt;push()&lt;/code&gt; methods can also optionally take a
&lt;a href=&#34;/morphia/1.4/morphia/1.4/javadoc?org/mongodb/morphia/query/PushOptions.html
&#34;&gt;&lt;code&gt;PushOptions&lt;/code&gt;&lt;/a&gt; instance allowing for tweaking how the values are added to the
list.  See &lt;a href=&#34;http://docs.mongodb.org/manual/reference/operator/update/push/#modifiers
&#34;&gt;the manual&lt;/a&gt; for more information about the various modifiers
available.&lt;/p&gt;

&lt;h3 id=&#34;removefirst-removelast-removeall&#34;&gt;removeFirst()/removeLast()/removeAll()&lt;/h3&gt;

&lt;p&gt;To remove values from a list, use &lt;code&gt;removeFirst()&lt;/code&gt;, &lt;code&gt;removeLast()&lt;/code&gt;, or &lt;code&gt;removeAll()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//given roomNumbers = [ 1, 2, 3 ]
ops = datastore
    .createUpdateOperations(Hotel.class)
    .removeFirst(&amp;quot;roomNumbers&amp;quot;);
datastore.update(updateQuery, ops);  // [ 2, 3 ]

//given roomNumbers = [ 1, 2, 3 ]
ops = datastore
    .createUpdateOperations(Hotel.class)
    .removeLast(&amp;quot;roomNumbers&amp;quot;);
datastore.update(updateQuery, ops);  // [ 1, 2 ]
ops = datastore
    .createUpdateOperations(Hotel.class)
    .removeLast(&amp;quot;roomNumbers&amp;quot;);
datastore.update(updateQuery, ops);  // [ 1 ]
ops = datastore
    .createUpdateOperations(Hotel.class)
    .removeLast(&amp;quot;roomNumbers&amp;quot;);
datastore.update(updateQuery, ops);  // []   empty array

//given roomNumbers = [ 1, 2, 3, 3 ]
ops = datastore
    .createUpdateOperations(Hotel.class)
    .removeAll(&amp;quot;roomNumbers&amp;quot;, 3);
datastore.update(updateQuery, ops);  // [ 1, 2 ]

//given roomNumbers = [ 1, 2, 3, 3 ]
ops = datastore
    .createUpdateOperations(Hotel.class)
    .removeAll(&amp;quot;roomNumbers&amp;quot;, Arrays.asList(2, 3));
datastore.update(updateQuery, ops);  // [ 1 ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;updatefirst&#34;&gt;updateFirst()&lt;/h3&gt;

&lt;p&gt;In the default driver and shell this is the default behavior. In Morphia we feel like updating all the results of the query is a better default (see below).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;    {
        name: &amp;quot;Fairmont&amp;quot;, 
        stars: 5
    },
    {
        name: &amp;quot;Last Chance&amp;quot;, 
        stars: 3 
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ops = datastore.createUpdateOperations(Hotel.class).inc(&amp;quot;stars&amp;quot;, 50);

// morphia exposes a specific updateFirst to update only the first hotel matching the query
datastore
    .updateFirst(datastore
        .find(Hotel.class)
        .order(&amp;quot;stars&amp;quot;),
        ops);  // update only Last Chance
datastore
    .updateFirst(datastore
        .find(Hotel.class)
        .order(&amp;quot;-stars&amp;quot;),
        ops); // update only Fairmont
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;multiple-operations&#34;&gt;Multiple Operations&lt;/h2&gt;

&lt;p&gt;You can also perform multiple update operations within a single update.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//set city to Ottawa and increment stars by 1
ops = datastore
    .createUpdateOperations(Hotel.class)
    .set(&amp;quot;city&amp;quot;, &amp;quot;Ottawa&amp;quot;)
    .inc(&amp;quot;stars&amp;quot;);
datastore.update(updateQuery, ops);

//if you perform multiple operations in one command on the same property, results will vary
ops = datastore
    .createUpdateOperations(Hotel.class)
    .inc(&amp;quot;stars&amp;quot;, 50)
    .inc(&amp;quot;stars&amp;quot;);  //increments by 1
ops = datastore
    .createUpdateOperations(Hotel.class)
    .inc(&amp;quot;stars&amp;quot;)
    .inc(&amp;quot;stars&amp;quot;, 50);  //increments by 50

//you can&#39;t apply conflicting operations to the same property
ops = datastore
    .createUpdateOperations(Hotel.class)
    .set(&amp;quot;stars&amp;quot;, 1)
    .inc(&amp;quot;stars&amp;quot;, 50); //causes error
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;createifmissing-overload-parameter&#34;&gt;createIfMissing (overload parameter)&lt;/h2&gt;

&lt;p&gt;All of the update methods on &lt;code&gt;Datastore&lt;/code&gt; are overloaded and accept a &lt;code&gt;createIfMissing&lt;/code&gt; parameter&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ops = datastore
    .createUpdateOperations(Hotel.class)
    .inc(&amp;quot;stars&amp;quot;, 50);

//update, if not found create it
datastore
    .updateFirst(datastore
        .createQuery(Hotel.class)
        .field(&amp;quot;stars&amp;quot;).greaterThan(100),
    ops, true);  

// creates { &amp;quot;_id&amp;quot; : ObjectId(&amp;quot;4c60629d2f1200000000161d&amp;quot;), &amp;quot;stars&amp;quot; : 50 }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Validation Extension</title>
      <link>/morphia/1.4/guides/validationExtension/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/morphia/1.4/guides/validationExtension/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This is a simple extension to Morphia to process JSR 303 Validation Annotations.&lt;/p&gt;

&lt;h1 id=&#34;using&#34;&gt;Using&lt;/h1&gt;

&lt;p&gt;Add this at the start of your application (or wherever you create your morphia instances).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new ValidationExtension(morphia);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Here is a simple example using (as an example) Hibernate validation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;...
import org.hibernate.validator.constraints.Email;
...

@Entity
public class Userlike {
	@Id ObjectId id;
	@Email String email;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;implementation&#34;&gt;Implementation&lt;/h1&gt;

&lt;p&gt;This is a lightweight wrapper around the JSR 303 API. It installs a simple global entity interceptor which listens to all
&lt;a href=&#34;/morphia/1.4/morphia/1.4/guides/lifeCycleMethods/&#34;&gt;life cycle methods&lt;/a&gt; needed for validation. You can use any implementation of JSR 303 by
just adding it to the classpath.&lt;/p&gt;

&lt;p&gt;You can look at the code &lt;a href=&#34;https://github.com/mongodb/morphia/blob/master/validation/src/main/java/org/mongodb/morphia/ValidationExtension.java
&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h2&gt;

&lt;h3 id=&#34;manual&#34;&gt;Manual&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://hibernate.org/validator/&#34;&gt;Hibernate Validator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;maven&#34;&gt;Maven&lt;/h3&gt;

&lt;p&gt;If you use Maven to manage your project, you can reference Morphia as a dependency:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mongodb.morphia&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;morphia-validation&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.4.0-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>