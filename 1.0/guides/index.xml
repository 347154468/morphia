<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Guides on Morphia</title>
    <link>/morphia/1.0/guides/</link>
    <description>Recent content in Guides on Morphia</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 17 Mar 2015 15:36:56 +0000</lastBuildDate>
    <atom:link href="/morphia/1.0/guides/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Annotations</title>
      <link>/morphia/1.0/guides/annotations/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/morphia/1.0/guides/annotations/</guid>
      <description>

&lt;h1 id=&#34;annotations&#34;&gt;Annotations&lt;/h1&gt;

&lt;p&gt;Below is a list of all the annotations and a brief description of how to use them.&lt;/p&gt;

&lt;h2 id=&#34;entity&#34;&gt;Entity&lt;/h2&gt;

&lt;p&gt;Marks entities to be stored directly in a collection. This annotations is optional in most cases (though this is likely to change in
future versions). There is no harm in including it to be more verbose, and make clear the intention for the class.  The definition of
this annotation looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface Entity {
  String value() default Mapper.IGNORED_FIELDNAME;
  CappedAt cap() default @CappedAt(0);
  boolean noClassnameStored() default false;
  boolean queryNonPrimary() default false;
  String concern() default &amp;quot;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;value()&lt;/td&gt;
&lt;td&gt;Defines the collection to use.  Defaults to using the classname&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cap()&lt;/td&gt;
&lt;td&gt;Marks this collection as capped and sets the size to use.  See the &lt;a href=&#34;#capped&#34;&gt;&lt;code&gt;@Capped&lt;/code&gt;&lt;/a&gt; below&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;noClassnameStored()&lt;/td&gt;
&lt;td&gt;Tells Morphia to not store the classname in the document.  The default is to store the classname.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;queryNonPrimary()&lt;/td&gt;
&lt;td&gt;Indicates that queries against this collection can use secondaries.  The default is primary only reads.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;concern()&lt;/td&gt;
&lt;td&gt;The WriteConcern to use when writing to this collection.  The default WriteConcern depends on how the &lt;code&gt;MongoClient&lt;/code&gt; passed to the &lt;code&gt;Datastore&lt;/code&gt; was created.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;indexes&#34;&gt;Indexes&lt;/h2&gt;

&lt;p&gt;In addition to being able to declare an index on a single field you can also declare the indexes at the class level. This allows you to
 create more than just a single field index; it allows you to create compound indexes with multiple fields.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface Indexes {
    Index[] value();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;index&#34;&gt;Index&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface Index {
    String value() default &amp;quot;&amp;quot;;
    String name() default &amp;quot;&amp;quot;;
    boolean unique() default false;
    boolean dropDups() default false;
    boolean background() default false;
    boolean sparse() default false;
    boolean disableValidation() default false;
    int expireAfterSeconds() default -1;

    Field[] fields() default {};
    IndexOptions options() default @IndexOptions();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two pieces to this annotation that are mutually exclusive.  The first group of parameters are considered legacy.  They are safe
 to use but are unlikely to survive past the 1.x series.  These options and more have been conglomerated in the &lt;code&gt;@IndexOptions&lt;/code&gt;
 annotation.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;value()&lt;/td&gt;
&lt;td&gt;List of fields (prepended with &amp;ldquo;-&amp;rdquo; for desc; defaults to asc).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;name()&lt;/td&gt;
&lt;td&gt;The name of the index&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;unique()&lt;/td&gt;
&lt;td&gt;Requires values in the index to be unique&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dropDups()&lt;/td&gt;
&lt;td&gt;Drop any duplicate values during the creation of a unique index.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;background()&lt;/td&gt;
&lt;td&gt;Create this index in the background.  There are some &lt;a href=&#34;http://docs.mongodb.org/manual/tutorial/build-indexes-in-the-background/#considerations&#34;&gt;considerations&lt;/a&gt; to keep in mind.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;sparse()&lt;/td&gt;
&lt;td&gt;Create a &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-sparse/&#34;&gt;sparse&lt;/a&gt; index&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;disableValidation()&lt;/td&gt;
&lt;td&gt;By default, Morphia will validate field names being index.  This disables those checks.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;expireAfterSeconds()&lt;/td&gt;
&lt;td&gt;Creates a &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-ttl/&#34;&gt;TTL Index&lt;/a&gt; on a date field.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;fields()&lt;/td&gt;
&lt;td&gt;This is the new way to define which fields to index. &lt;a href=&#34;#Field&#34;&gt;Details&lt;/a&gt; can be found below.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;options()&lt;/td&gt;
&lt;td&gt;This is the new way to define index options. &lt;a href=&#34;#IndexOptions&#34;&gt;Details&lt;/a&gt; can be found below.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;field&#34;&gt;Field&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; public @interface Field {
     String value();
     IndexType type() default IndexType.ASC;
     int weight() default -1;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;value()&lt;/td&gt;
&lt;td&gt;The field to include in the index&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;type()&lt;/td&gt;
&lt;td&gt;The type of index to create.  This includes the following values:   &lt;code&gt;ASC&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt;, &lt;code&gt;GEO2D&lt;/code&gt;, &lt;code&gt;GEO2DSPHERE&lt;/code&gt;, &lt;code&gt;TEXT&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;weight()&lt;/td&gt;
&lt;td&gt;When defining a text index, this is the weight to apply&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;indexoptions&#34;&gt;IndexOptions&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface IndexOptions {
    String name() default &amp;quot;&amp;quot;;
    boolean unique() default false;
    boolean dropDups() default false;
    boolean background() default false;
    boolean sparse() default false;
    boolean disableValidation() default false;
    int expireAfterSeconds() default -1;
    String language() default &amp;quot;&amp;quot;;
    String languageOverride() default &amp;quot;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;name()&lt;/td&gt;
&lt;td&gt;The name of the index&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;unique()&lt;/td&gt;
&lt;td&gt;Requires values in the index to be unique&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dropDups()&lt;/td&gt;
&lt;td&gt;Drop any duplicate values during the creation of a unique index.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;background()&lt;/td&gt;
&lt;td&gt;Create this index in the background.  There are some &lt;a href=&#34;http://docs.mongodb.org/manual/tutorial/build-indexes-in-the-background/#considerations&#34;&gt;considerations&lt;/a&gt; to keep in mind.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;sparse()&lt;/td&gt;
&lt;td&gt;Create a &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-sparse/&#34;&gt;sparse&lt;/a&gt; index&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;expireAfterSeconds()&lt;/td&gt;
&lt;td&gt;Creates a &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-ttl/&#34;&gt;TTL Index&lt;/a&gt; on a date field.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;disableValidation()&lt;/td&gt;
&lt;td&gt;By default, Morphia will validate field names being index.  This disables those checks.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;language()&lt;/td&gt;
&lt;td&gt;Default language for the index.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;languageOverride()&lt;/td&gt;
&lt;td&gt;The field in the document to use to override the default language.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;indexed&#34;&gt;Indexed&lt;/h4&gt;

&lt;p&gt;Applied to a Java field, marks the field to be indexed by MongoDB.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface Indexed {
    IndexDirection value() default IndexDirection.ASC;
    String name() default &amp;quot;&amp;quot;;
    boolean unique() default false;
    boolean dropDups() default false;
    boolean background() default false;
    boolean sparse() default false;
    int expireAfterSeconds() default -1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;value()&lt;/td&gt;
&lt;td&gt;The sort direction for the index&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;name()&lt;/td&gt;
&lt;td&gt;The name of the index&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;unique()&lt;/td&gt;
&lt;td&gt;Requires values in the index to be unique&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dropDups()&lt;/td&gt;
&lt;td&gt;Drop any duplicate values during the creation of a unique index.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;background()&lt;/td&gt;
&lt;td&gt;Create this index in the background.  There are some &lt;a href=&#34;http://docs.mongodb.org/manual/tutorial/build-indexes-in-the-background/#considerations&#34;&gt;considerations&lt;/a&gt; to keep in mind.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;sparse()&lt;/td&gt;
&lt;td&gt;Create a &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-sparse/&#34;&gt;sparse&lt;/a&gt; index&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;expireAfterSeconds()&lt;/td&gt;
&lt;td&gt;Creates a &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-ttl/&#34;&gt;TTL Index&lt;/a&gt; on a date field.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;id&#34;&gt;Id&lt;/h2&gt;

&lt;p&gt;Marks a field in an &lt;code&gt;@Entity&lt;/code&gt; to be the &amp;ldquo;_id&amp;rdquo; field in MongoDB.&lt;/p&gt;

&lt;h2 id=&#34;property&#34;&gt;Property&lt;/h2&gt;

&lt;p&gt;An optional annotation instructing Morphia to persist the field in to the document given to MongoDB.  By default, the field name is used
 as the property name.  This can be overridden by passing a String with the new name to the annotation.&lt;/p&gt;

&lt;h2 id=&#34;transient&#34;&gt;Transient&lt;/h2&gt;

&lt;p&gt;Instructs Morphia to ignore this field when converting an entity to a document.  The Java keyword &lt;code&gt;transient&lt;/code&gt; can also be used instead.&lt;/p&gt;

&lt;h2 id=&#34;serialized&#34;&gt;Serialized&lt;/h2&gt;

&lt;p&gt;Instructs Morphia to serialize this field using JDK serialization.  The field&amp;rsquo;s value gets converted to a &lt;code&gt;byte[]&lt;/code&gt; and passed
 off to MongoDB.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface Serialized {
  String value() default Mapper.IGNORED_FIELDNAME;
  boolean disableCompression() default false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;value()&lt;/td&gt;
&lt;td&gt;the field name to use in the document&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;disableCompression()&lt;/td&gt;
&lt;td&gt;By default, Morphia compresses the &lt;code&gt;byte[]&lt;/code&gt; after serialization.  Setting this to true disables the compression.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;notsaved&#34;&gt;NotSaved&lt;/h2&gt;

&lt;p&gt;Instructs Morphia to ignore this field when saving but will still be loaded.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Good for data migration.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;alsoload&#34;&gt;AlsoLoad&lt;/h2&gt;

&lt;p&gt;When a field gets remapped to a new name, you can either update the database and migrate all the fields at once or use this annotation
to tell Morphia what older names to try if the current one fails.  It is an error to have values under both the old and new key names
when loading a document.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Good for data migration.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface AlsoLoad {
  String[] value();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;value()&lt;/td&gt;
&lt;td&gt;The array of names to try when loading the field&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;version&#34;&gt;Version&lt;/h2&gt;

&lt;p&gt;Marks a field in an &lt;code&gt;@Entity&lt;/code&gt; to control optimistic locking for that entity. If the versions change while modifying an entity (including
deletes) a &lt;code&gt;ConcurrentModificationException&lt;/code&gt; will be thrown. This field will be automatically managed for you &amp;ndash; there is no need to set
 a value and you should not do so anyway.  If another name beside the Java field name is desired, a name can be passed to this
 annotation to change the document&amp;rsquo;s field name.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Entity
class MyClass {
   ...
   @Version Long v;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;p&gt;Marks fields as stored in another collection and which are linked (by a &lt;code&gt;DBRef&lt;/code&gt; field). When the Entity is loaded, the referenced Entity
 can also be loaded.  Any document referenced via an &lt;code&gt;@Reference&lt;/code&gt; field must have already been saved in MongoDB or have the Java object&amp;rsquo;s
  &lt;code&gt;@Id&lt;/code&gt; already assigned.  Otherwise, no key can be copied in to the &lt;code&gt;Key&lt;/code&gt; for storage in the database.  If you&amp;rsquo;re always saving the
  referenced entity in the mapped collection (&lt;code&gt;Datastore&lt;/code&gt; can be told to save in to a collection other than the mapped collection) a lot
  of space can be saved by using the &lt;code&gt;idOnly()&lt;/code&gt; parameter to just save the key value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface Reference {
  String value() default Mapper.IGNORED_FIELDNAME;
  Class&amp;lt;?&amp;gt; concreteClass() default Object.class;
  boolean ignoreMissing() default false;
  boolean lazy() default false;
  boolean idOnly() default false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;value()&lt;/td&gt;
&lt;td&gt;The field name to use in the document.  Defaults to the Java field name.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ignoreMissing()&lt;/td&gt;
&lt;td&gt;Ignore any missing documents&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;lazy()&lt;/td&gt;
&lt;td&gt;Instructs Morphia to defer loading of the referenced document.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;idOnly()&lt;/td&gt;
&lt;td&gt;Instructs Morphia to only store the key of the referenced document rather than a full &lt;code&gt;DBRef&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;embedded&#34;&gt;Embedded&lt;/h2&gt;

&lt;p&gt;In contrast to &lt;code&gt;@Reference&lt;/code&gt; where a nested Java reference ends up as a separate document in a collection, &lt;code&gt;@Embedded&lt;/code&gt; tells Morphia
to embed the document created from the Java object in the document of the parent object.  This annotation can be applied to the class of
the embedded type or on the field holding the embedded instance.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface Embedded {
  String value() default Mapper.IGNORED_FIELDNAME;
  Class&amp;lt;?&amp;gt; concreteClass() default Object.class;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Usage&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;value()&lt;/td&gt;
&lt;td&gt;The field name to use in the document.  Defaults to the Java field name.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;concreteClass()&lt;/td&gt;
&lt;td&gt;The concrete class to use when instantiating the embedded entity&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;lifecycle-annotations&#34;&gt;Lifecycle Annotations&lt;/h2&gt;

&lt;p&gt;There are various annotations which can be used to register callbacks on certain lifecycle events. These include Pre/Post-Persist (Save), and Pre/Post-Load.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@PreLoad&lt;/code&gt; - Called before mapping the datastore object to the entity (POJO); the DBObject is passed as an argument (you can add/remove/change values)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PostLoad&lt;/code&gt; - Called after mapping to the entity&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PrePersist&lt;/code&gt; - Called before save, it can return a DBObject in place of an empty one.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PostSave&lt;/code&gt; - Called before the save call to the datastore&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PostPersist&lt;/code&gt; - Called after the save call to the datastore&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mongodb/morphia/blob/master/morphia/src/test/java/org/mongodb/morphia/TestQuery.java#L63&#34;&gt;This&lt;/a&gt; is one of the test
classes.&lt;/p&gt;

&lt;p&gt;All parameters and return values are optional in your implemented methods.&lt;/p&gt;

&lt;h4 id=&#34;prepersist&#34;&gt;&lt;code&gt;@PrePersist&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;Here is a simple example of an entity that always saves the Date it was last updated at.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class BankAccount {
  @Id String id;
  Date lastUpdated = new Date();

  @PrePersist void prePersist() {lastUpdated = new Date();}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;entitylisteners&#34;&gt;&lt;code&gt;@EntityListeners&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;In addition, you can separate the lifecycle event implementation in an external class, or many.
```java
@EntityListeners(BackAccountWatcher.class)
public class BankAccount {
  @Id String id;
  Date lastUpdated = new Date();
}&lt;/p&gt;

&lt;p&gt;class BankAccountWatcher{&lt;/p&gt;

&lt;p&gt;@PrePersist void prePersist(BankAccount act) {act.lastUpdated = new Date();}&lt;/p&gt;

&lt;p&gt;}
```&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reference Guides</title>
      <link>/morphia/1.0/guides/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/morphia/1.0/guides/</guid>
      <description>

&lt;h2 id=&#34;reference-guides&#34;&gt;Reference Guides&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/morphia/1.0/morphia/1.0/guides/annotations/&#34;&gt;Annotations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/morphia/1.0/morphia/1.0/guides/aggregation/&#34;&gt;Aggregation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Aggregation</title>
      <link>/morphia/1.0/guides/aggregation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/morphia/1.0/guides/aggregation/</guid>
      <description>

&lt;h1 id=&#34;aggregation&#34;&gt;Aggregation&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;http://docs.mongodb.org/manual/aggregation/&#34;&gt;aggregation&lt;/a&gt; framework in MongoDB allows you to define a series (called a pipeline) of
operations (called stages) against the data in a collection.  These pipelines can be used for analytics or they can be used to
convert your data from one form to another.  This guide will not go in to the details of how aggregation works, however.  The official
 MongoDB &lt;a href=&#34;http://docs.mongodb.org/manual/aggregation/&#34;&gt;documentation&lt;/a&gt; has extensive tutorials on such details.  Rather, this guide will
 focus on the Morphia API.  The examples shown here are taken from the &lt;a href=&#34;https://github.com/mongodb/morphia/blob/master/morphia/src/test/java/org/mongodb/morphia/aggregation/AggregationTest.java
&#34;&gt;tests&lt;/a&gt; in Morphia itself.&lt;/p&gt;

&lt;p&gt;Writing an aggregation pipeline starts just like writing a standard query.  As with querying, we start with the &lt;code&gt;Datastore&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Iterator&amp;lt;Author&amp;gt; aggregate = datastore.createAggregation(Book.class)
      .group(&amp;quot;author&amp;quot;, grouping(&amp;quot;books&amp;quot;, push(&amp;quot;title&amp;quot;)))
      .out(Author.class, options);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;createAggregation()&lt;/code&gt; takes a &lt;code&gt;Class&lt;/code&gt; literal.  This lets Morphia know which collection to perform this aggregation
against.  Because of the transformational operations available in the aggregation &lt;a href=&#34;http://docs.mongodb
.org/manual/core/aggregation-pipeline/&#34;&gt;pipeline&lt;/a&gt;, Morphia can not validate as much as it can with querying so care will need to be taken to ensure
 document fields actual exist when referencing them in your pipeline.&lt;/p&gt;

&lt;h2 id=&#34;the-pipeline&#34;&gt;The Pipeline&lt;/h2&gt;

&lt;p&gt;Aggregation operations are comprised of a series stages.  Our example here has only one stage: &lt;code&gt;group()&lt;/code&gt;.  This method is the Morphia
equivalent of the &lt;code&gt;$group&lt;/code&gt; operator.  This stage, as the name suggests, groups together documents based on the given field&amp;rsquo;s values.  In this
  example, we are collecting together all the books by author.  The first parameter to &lt;code&gt;group()&lt;/code&gt; defines the &lt;code&gt;_id&lt;/code&gt; of the resulting
  documents.  Within this grouping, this pipeline takes the &lt;code&gt;books&lt;/code&gt; fields for each author and extracts the &lt;code&gt;title&lt;/code&gt;.  With this grouping
  of data, we&amp;rsquo;re then &lt;code&gt;push()&lt;/code&gt;ing the titles in to an array in the final document.  This example is the Morphia equivalent of an
  &lt;a href=&#34;http://docs.mongodb.org/manual/reference/operator/aggregation/group/#group-title-by-author&#34;&gt;example&lt;/a&gt; found in the aggregation
  tutorials.  In that tutorial example, you can see what the resulting aggregation pipeline would look like as well as the resulting
  documents after the pipeline is executed.&lt;/p&gt;

&lt;h2 id=&#34;executing-the-pipeline&#34;&gt;Executing the Pipeline&lt;/h2&gt;

&lt;p&gt;There are two basic ways to execute an aggregation pipeline:  &lt;code&gt;aggregate()&lt;/code&gt; and &lt;code&gt;out()&lt;/code&gt;.  These methods are Morphia&amp;rsquo;s cues to send the
pipeline to MongoDB for execution.  In that regard, both are similar.  In practice, how the results are processed is even very similar.&lt;br /&gt;
The differences, however, can have huge implications on the performance of your application.  &lt;code&gt;aggregate()&lt;/code&gt; by default will use the
&amp;lsquo;inline&amp;rsquo; method for return the aggregation results.  This approach has the same 16MB limitation that all documents in MongoDB share.  The
 &lt;code&gt;options&lt;/code&gt; reference we passed in to &lt;code&gt;out()&lt;/code&gt; also applies to &lt;code&gt;aggregate()&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;aggregation-options&#34;&gt;Aggregation Options&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;options&lt;/code&gt; reference passed to &lt;code&gt;out()&lt;/code&gt; above is an instance of &lt;a href=&#34;http://api.mongodb.org/java/3.0/com/mongodb/AggregationOptions.html&#34;&gt;&lt;code&gt;AggregationOptions&lt;/code&gt;&lt;/a&gt;.  There are a handful options here but there&amp;rsquo;s one that deserves some
extra attention. As mentioned, the aggregation pipeline, by default, returns everything &amp;ldquo;inline&amp;rdquo; but as of MongoDB 2.6 you can tell
the aggregation engine to return a cursor instead.  This is what the value of &lt;a href=&#34;http://api.mongodb
.org/java/3.0/com/mongodb/AggregationOptions.html#getOutputMode--&#34;&gt;AggregationOptions#getOutputMode()&lt;/a&gt; determines.  The default value is to return them inline but it can be
 configured to return a cursor instead which means that your result size can be much larger than 16MB.  The options can also be
 configured to update the batch size or to set the time out threshold after which an aggregation will fail.  It is also possible to tell
  the aggregation engine to use disk space which allows, among other things, sorting of larger datasets than what can fit in to memory
  on the server.&lt;/p&gt;

&lt;h3 id=&#34;out&#34;&gt;$out&lt;/h3&gt;

&lt;p&gt;But this example doesn&amp;rsquo;t use &lt;code&gt;aggregate()&lt;/code&gt;, of course, it uses &lt;code&gt;out()&lt;/code&gt; which gives us access to the &lt;code&gt;$out&lt;/code&gt; pipeline stage.  &lt;a href=&#34;http://docs.mongodb.org/manual/reference/operator/aggregation/out/&#34;&gt;&lt;code&gt;$out&lt;/code&gt;&lt;/a&gt; is a new operator in MongoDB 2.6 that allows the results of a
pipeline to be stored in to a named collection.  This collection can not be sharded or a capped collection, however.  This collection,
if it does not exist, will be created upon execution of the pipeline.  &lt;em&gt;&lt;strong&gt;Any existing data in the collection will be lost and replaced
by the output of the aggregation.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;out()&lt;/code&gt; is implicitly asking for the results to be returned via a cursor.  What is happening under the covers is the aggregation
engine is writing out to the collection and is done.  Morphia goes one extra step further and executes an implicit &lt;code&gt;find&lt;/code&gt; on the output
collection and returns a cursor for all the documents in the collection.  In practice, this behaves no differently than setting the
output mode to &lt;code&gt;CURSOR&lt;/code&gt; with &lt;code&gt;aggregate()&lt;/code&gt; and your application need not know the difference.  It does, of course, have an impact on your
database and any existing data.  The use of &lt;code&gt;$out&lt;/code&gt; and &lt;code&gt;out()&lt;/code&gt; can be greatly beneficial in scenarios such as precomputed aggregated
results for later retrieval.&lt;/p&gt;

&lt;h3 id=&#34;typed-results&#34;&gt;Typed Results&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;out()&lt;/code&gt; has several variants.  In this example, we&amp;rsquo;re passing in &lt;code&gt;Author.class&lt;/code&gt; which tells Morphia that we want to map each document
returned to an instance of &lt;code&gt;Author&lt;/code&gt;.  Because we&amp;rsquo;re using &lt;code&gt;out()&lt;/code&gt; instead of &lt;code&gt;aggregate()&lt;/code&gt;, Morphia will use the mapped collection for
&lt;code&gt;Author&lt;/code&gt; as the output collection for the pipeline.  If you&amp;rsquo;d like to use an alternate collection but still return a cursor of &lt;code&gt;Author&lt;/code&gt;
instances, you can use &lt;a href=&#34;/morphia/1.0/javadoc/org/mongodb/morphia/aggregation/AggregationPipeline.html#out-java
.lang.String-java.lang.Class-com.mongodb.AggregationOptions-&#34;&gt;&lt;code&gt;out(String,Class,AggregationOptions)&lt;/code&gt;&lt;/a&gt; instead.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>